\chapter{Motivation}
% \begin{itemize}
%     \item Classical control flow vs quantum control flow~\cite{YYF12}
%     \item \emph{Intro quantum control flow}
% \end{itemize}
With the emergence of quantum computing, many quantum languages were introduced. Most languages focus on a lower level representation of quantum circuits. An example would be the popular Open Quantum Assembly Language (QASM)\cite{CBSG17}. QASM consists mainly of quantum and classical gates that can be manipulated by predefined and composite gates as well as limited (classical) if-statements. There are also languages with a focus on high level interactions, e.g. Tower\cite{ChMi22} which contains data structures in superposition, and Silq~\cite{BBGV20} which allows for automatic uncomputing of registers. What all these languages have in common is the restriction to quantum data while using only classical control flow. Although quantum control flow was defined by Ying et al.~\cite{YYF12} over 10 years ago, only very few languages have incorporated the principle. One example is the functional programming language proposed by Altenkirch et al.~\cite{AlGr05} where \texttt{if$^\circ$} is used to define the Hadamar gate. Only recently was the Quantum Control Machine (QCM) with quantum control flow at its core proposed by Yuan et al.~\cite{YVC24}. 

The QCMs syntax and logic are both heavily influenced by classical assembly languages. The language consists of quantum registers, gate, swap and get-bit operations\footnote{The gate operations are limited to the Hadamar and NOT gates.}, simple numeric operations on registers, and, finally, jump instructions. The jump instructions range from simple to conditional to indirect and are used to enable quantum control flow. Although the jump instructions are basic on jumps in classical computers, they are heavily limited by two concepts quantum computers based on unitary gates must adhere to, \emph{reversibility} and \emph{synchronization}.~\cite{YVC24}

Because quantum computers are based on unitary gates, all there operations need to be unitary and, therefore, reversible as well. This also includes jump instructions which are not reversible in classical computers.\unsure{ Example for non-reversibility?} To ensure reversibility of jumps, the QCM uses a \emph{branch control register} which values controls how much the instruction pointer of the machine advances after an execution. The branch control register can then be manipulated reversibly. The idea of a branch control register can also be found in reversible architectures for classical machines\cite{AGY07, TAG12}.

Although such a program counter addresses the issue of reversibility, it can become entangled with data registers when in superposition. This can lead to disruptive entanglement where the output of the program becomes invalid.~\cite{YVC24} To prevent any disruptive entanglement of the data and control registers, the QCM adheres to the principle of synchronization. It requires that the control flow is separated from the data at the end of execution. 

\begin{itemize}
    \item bounded by reversibility and synchronicity
    \begin{itemize}
        %\item what is reversibility, why is it needed
        \item what is synchronicity, why is it needed
    \end{itemize}
  %  \item based on classical assembly languages (jumps, registers, ...)
\end{itemize}

\begin{itemize}
    \item Issues with qcm
    \item very unreadable
    \item can be reduced to basics
\end{itemize}