\chapter{Motivation}
% \begin{itemize}
%     \item Classical control flow vs quantum control flow~\cite{YYF12}
%     \item \emph{Intro quantum control flow}
% \end{itemize}
With the emergence of quantum computing, many quantum languages were introduced. Most languages focus on a lower level representation of quantum circuits. An example would be the popular Open Quantum Assembly Language (QASM)\cite{CBSG17}. QASM consists mainly of quantum and classical gates that can be manipulated by predefined and composite gates as well as limited (classical) if-statements. There are also languages with a focus on high level interactions, e.g. Tower\cite{ChMi22} which contains data structures in superposition, and Silq~\cite{BBGV20} which allows for automatic uncomputing of registers. What all these languages have in common is the restriction to quantum data while using only classical control flow. Although quantum control flow was defined by Ying et al.~\cite{YYF12} over 10 years ago, only very few languages have incorporated the principle. One example is the functional programming language proposed by Altenkirch et al.~\cite{AlGr05} where \texttt{if$^\circ$} is used to define the Hadamar gate. Only recently was the Quantum Control Machine (QCM) with quantum control flow at its core proposed by Yuan et al.~\cite{YVC24}. 

The QCMs syntax and logic are both heavily influenced by classical assembly languages. The language consists of quantum registers, gate, swap and get-bit operations\footnote{The gate operations are limited to the Hadamar and NOT gates.}, simple numeric operations on registers, and, finally, jump instructions. The jump instructions range from simple to conditional to indirect and are used to enable quantum control flow. Although the jump instructions are basic on jumps in classical computers, they are heavily limited by two concepts quantum computers based on unitary gates must adhere to, \emph{reversibility} and \emph{synchronization}.~\cite{YVC24}

Because quantum computers are based on unitary gates, all there operations need to be unitary and, therefore, reversible as well. This also includes jump instructions which are not reversible in classical computers.\unsure{ Example for non-reversibility?} To ensure reversibility of jumps, the QCM uses a \emph{branch control register} which values controls how much the instruction pointer of the machine advances after an execution. The branch control register can then be manipulated reversibly. The idea of a branch control register can also be found in reversible architectures for classical machines\cite{AGY07, TAG12}.

Although such a program counter addresses the issue of reversibility, it can become entangled with data registers when in superposition. This can lead to disruptive entanglement where the output of the program becomes invalid.~\cite{YVC24} To prevent any disruptive entanglement of the data and control registers, the QCM adheres to the principle of synchronization. 
It requires that the control flow is separated from the data at the end of execution. 
Examples where synchronization comes into play are given in Fig.~\ref{fig:qcm_not_sync} and Fig.~\ref{fig:qcm_sync} where $x^y$ and $x^{\texttt{min}\{y, max\}}$ are calculated respectively. 
While the first example is completely reversible, it does not adhere to the principle of synchronization. Given the inputs two different inputs, the loop will be executed a different amount of times. This means that after the faster input completed the loop, the program counter of the slower input cannot catch up. To prevent this issue, the second program uses padding which is executed instead of the main loop. 
\begin{figure}
    \centering     
    \begin{minipage}{.40\textwidth}
        \vspace{7.5em}
        \begin{lstlisting}[linewidth=17em,style=QCM]
    add   res $1
    add   r1  y
l1: rjne  l3  r1  y
l2: jz    l4  r1
    mul   res x
    radd  r1  $1
l3: jmp   l1  
l4: rjmp  l2      
        \end{lstlisting}
        \caption{QCM exponentiation without synchronization}
        \label{fig:qcm_not_sync}
    \end{minipage}
    \hfill
    \begin{minipage}{.55\textwidth}
        \begin{lstlisting}[linewidth=23em,style=QCM]
    add   res $1
    add   r1  max
l1: rjne  l3  r1  max
l2: jz    l4  r1
l5: jg    l7  r1  y   
    mul   res x
l6: jmp   l8  
l7: rjmp  l5
    nop           ; padding
l8: rjle  l6  r1  y
    radd  r1  $1
l3: jmp   l1
l4: rjmp  l2
        \end{lstlisting}
        \caption{Synchronized QCM exponentiation}    
        \label{fig:qcm_sync}
    \end{minipage}
\end{figure}

% \begin{itemize}
%     \item bounded by reversibility and synchronicity
%     \begin{itemize}
%         %\item what is reversibility, why is it needed
%         \item what is synchronicity, why is it needed
%     \end{itemize}
%   %  \item based on classical assembly languages (jumps, registers, ...)
% \end{itemize}


\begin{itemize}
    \item Issues with qcm
    \begin{itemize}
        \item Reversibility always requires "back" jmps
        \item Synchronization can be easily missed (e.g. passing in while)\unsure{add lstlistings of to programs annotated to clarify jumps}
        \item Overall hard to read and program in code 
    \end{itemize}
    \item Idea 
    \begin{itemize}
        \item reduce QCM to basics
        \item lead to concept section
    \end{itemize}
\end{itemize}