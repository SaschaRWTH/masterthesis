% This file was created with Citavi 6.18.0.1

@article{ACR*10,
 author = {Ambainis, A. and Childs, A. M. and Reichardt, B. W. and {\v{S}}palek, R. and Zhang, S.},
 year = {2010},
 title = {Any AND-OR Formula of Size N Can Be Evaluated in Time {\$}N{\^{}}{1/2+o(1)}{\$} on a Quantum Computer},
 pages = {2513--2530},
 volume = {39},
 number = {6},
 issn = {0097-5397},
 journal = {SIAM Journal on Computing},
 doi = {10.1137/080712167}
}


@incollection{AGY07,
 author = {Axelsen, Holger Bock and Gl{\"u}ck, Robert and Yokoyama, Tetsuo},
 title = {Reversible Machine Code and Its Abstract Processor Architecture},
 pages = {56--69},
 volume = {4649},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-540-74509-9},
 series = {Lecture Notes in Computer Science},
 editor = {Diekert, Volker and Volkov, Mikhail V. and Voronkov, Andrei},
 booktitle = {Computer Science -- Theory and Applications},
 year = {2007},
 address = {Berlin, Heidelberg},
 doi = {10.1007/978-3-540-74510-5{\textunderscore }9}
}


@inproceedings{AlGr05,
 abstract = {We introduce the language QML, a functional language for quantum computations on finite types. Its design is guided by its categorical semantics: QML programs are interpreted by morphisms in the category FQC of finite quantum computations, which provides a constructive semantics of irreversible quantum computations realisable as quantum gates. QML integrates reversible and irreversible quantum computations in one language, using first order strict linear logic to make weakenings explicit. Strict programs are free from decoherence and hence preserve superpositions and entanglement -which is essential for quantum parallelism.},
 author = {Altenkirch, T. and Grattage, J.},
 title = {A Functional Quantum Programming Language},
 pages = {249--258},
 publisher = {IEEE},
 isbn = {0-7695-2266-1},
 booktitle = {20th Annual IEEE Symposium on Logic in Computer Science (LICS' 05)},
 year = {2005},
 doi = {10.1109/LICS.2005.1}
}


@incollection{Axel11,
 author = {Axelsen, Holger Bock},
 title = {Clean Translation of an Imperative Reversible Programming Language},
 pages = {144--163},
 volume = {6601},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-642-19860-1},
 series = {Lecture Notes in Computer Science},
 editor = {Knoop, Jens},
 booktitle = {Compiler Construction},
 year = {2011},
 address = {Berlin, Heidelberg},
 doi = {10.1007/978-3-642-19861-8{\textunderscore }9}
}


@incollection{AxGl11,
 author = {Axelsen, Holger Bock and Gl{\"u}ck, Robert},
 title = {What Do Reversible Programs Compute?},
 pages = {42--56},
 volume = {6604},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-642-19804-5},
 series = {Lecture Notes in Computer Science},
 editor = {Hofmann, Martin},
 booktitle = {Foundations of Software Science and Computational Structures},
 year = {2011},
 address = {Berlin, Heidelberg},
 doi = {10.1007/978-3-642-19805-2{\textunderscore }4}
}


@inproceedings{BBGV20,
 author = {Bichsel, Benjamin and Baader, Maximilian and Gehr, Timon and Vechev, Martin},
 title = {Silq: a high-level quantum language with safe uncomputation and intuitive semantics},
 pages = {286--300},
 publisher = {ACM},
 isbn = {9781450376136},
 editor = {Donaldson, Alastair F. and Torlak, Emina},
 booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
 year = {2020},
 address = {New York, NY, USA},
 doi = {10.1145/3385412.3386007}
}


@inproceedings{BFA22,
 author = {Bandic, Medina and Feld, Sebastian and Almudever, Carmen G.},
 title = {Full-stack quantum computing systems in the NISQ era: algorithm-driven and hardware-aware compilation techniques},
 pages = {1--6},
 publisher = {{European Design and Automation Association}},
 isbn = {978-3-9819263-6-1},
 series = {ACM Conferences},
 editor = {Bolchini, Cristiana},
 booktitle = {Proceedings of the 2022 Conference et Exhibition on Design, Automation et Test in Europe},
 year = {2022},
 address = {Leuven,Belgium},
 doi = {10.23919/DATE54114.2022.9774643}
}


@article{BML,
 abstract = {In this paper we review main ideas mentioned in several other papers which talk about optimization techniques used by compilers. Here we focus on loop unrolling technique and its effect on power consumption, energy usage and also its impact on program speed up by achieving ILP (Instruction-level parallelism). Concentrating on superscalar processors, we discuss the idea of generalized loop unrolling presented by J.C. Hang and T. Leng and then we present a new method to traverse a linked list to get a better result of loop unrolling in that case. After that we mention the results of some experiments carried out on a Pentium 4 processor (as an instance of super scalar architecture). Furthermore, the results of some other experiments on supercomputer (the Alliat FX/2800 System) containing superscalar node processors would be mentioned. These experiments show that loop unrolling has a slight measurable effect on energy usage as well as power consumption. But it could be an effective way for program speed up.},
 author = {Booshehri, Meisam and Malekpour, Abbas and Luksch, Peter},
 title = {An Improving Method for Loop Unrolling},
 url = {http://arxiv.org/pdf/1308.0698},
 volume = {11},
 number = {5},
 journal = {International Journal of Computer Science and Information Security, Vol. 11, No. 5, pp. 73-76}
}


@misc{BMTM20,
 abstract = {Artifact for PLDI'20 paper {\textquotedbl}Silq: A High-level Quantum Programming Language with Safe Uncomputation and Intuitive Semantics{\textquotedbl}.},
 author = {{Benjamin Bichsel} and {Maximilian Baader} and {Timon Gehr} and {Martin Vechev}},
 year = {2020},
 title = {tgehr/silq-artifact: PLDI'20 artifact},
 publisher = {Zenodo},
 doi = {10.5281/zenodo.3764961}
}


@misc{CBSG17,
 abstract = {This document describes a quantum assembly language (QASM) called OpenQASM that is used to implement experiments with low depth quantum circuits. OpenQASM represents universal physical circuits over the CNOT plus SU(2) basis with straight-line code that includes measurement, reset, fast feedback, and gate subroutines. The simple text language can be written by hand or by higher level tools and may be executed on the IBM Q Experience.},
 author = {Cross, Andrew W. and Bishop, Lev S. and Smolin, John A. and Gambetta, Jay M.},
 date = {11.07.2017},
 title = {Open Quantum Assembly Language},
 url = {http://arxiv.org/pdf/1707.03429}
}


@article{CFM17,
 abstract = {Quantum computing sits at an important inflection point. For years, high-level algorithms for quantum computers have shown considerable promise, and recent advances in quantum device fabrication offer hope of utility. A gap still exists, however, between the hardware size and reliability requirements of quantum computing algorithms and the physical machines foreseen within the next ten years. To bridge this gap, quantum computers require appropriate software to translate and optimize applications (toolflows) and abstraction layers. Given the stringent resource constraints in quantum computing, information passed between layers of software and implementations will differ markedly from in classical computing. Quantum toolflows must expose more physical details between layers, so the challenge is to find abstractions that expose key details while hiding enough complexity.},
 author = {Chong, Frederic T. and Franklin, Diana and Martonosi, Margaret},
 year = {2017},
 title = {Programming languages and compiler design for realistic quantum hardware},
 pages = {180--187},
 volume = {549},
 number = {7671},
 journal = {Nature},
 doi = {10.1038/nature23459}
}


@misc{ChMi22,
 abstract = {OOPSLA 2022 Artifact: Tower

This artifact is being submitted to support the OOPSLA'22 paper {\textquotedbl}Tower: Data Structures in Quantum Superposition{\textquotedbl} by Charles Yuan and Michael Carbin. The artifact contains:

README.md, this document

tower.tgz, a Docker image containing source code, pre-built binaries, and tests

tower.dockerfile, a Dockerfile that generates the above image from scratch

The directory~oopsla22-artifact, a copy of the contents of the Docker image, containing the source code of the Tower language interpreter (src/) and the tests (tests/)

This document describes:

The claims of the paper this artifact supports

The kick-the-tires instructions for reviewers

How to review the artifact for functionality

How to review the artifact for reusability

Detailed instructions for building the artifact

The contents of this artifact, and the sources of the Tower programming language, are available on~{\textless}a href={\textquotedbl}https://github.com/psg-mit/tower-oopsla22{\textquotedbl}{\textgreater}GitHub.

Claims Supported by Artifact

This artifact supports the following claims of the paper:

(Section 7) We implemented an interpreter for Tower in OCaml that classically executes the operational semantics of the language.

This claim is evaluated by Step 2 of the section {\textquotedbl}Validating the Paper's Claims{\textquotedbl} below. The artifact provides the source code of the Tower interpreter and a suite of test cases (from Table 1 of the paper) that the interpreter can execute.

(Section 8) We implemented Ground, a library of abstract data structures in Tower, and tested its operations with the interpreter.

This claim is evaluated by Steps 2 and 3 of the section {\textquotedbl}Validating the Paper's Claims{\textquotedbl} below. The artifact provides the source code of the Ground library, including all operations described in Table 1 of the paper, and a suite of tests for the correctness of the implementation that can be executed with the provided interpreter. The artifact also includes a script that validates the complexities of the data structure operations indicated by the {\textquotedbl}Complexity{\textquotedbl} column in Table 1 of the paper.

Kick-the-Tires: Getting Started with the Artifact

First, import~tower.tgz~into Docker. In our testing, we used Docker Engine 20.10.17 on macOS Monterey. The image may be loaded using the following commands:

{\$} docker load {\textless} tower.tgz

Loaded image: oopsla22-artifact:latest

{\$} docker run -it --rm oopsla22-artifact bash

opam@502e0da78017:{\~{}}/oopsla22-artifact{\$}

The artifact is in the~oopsla22-artifact/~directory inside the user home directory, inside which the interpreter for Tower is already installed as~./tower.

{\$} cd {\~{}}/oopsla22-artifact/

{\$} ./tower -help

The interpreter for the Tower quantum programming language.

Usage: ./tower  [program]

Options are:

-v Run in verbose mode.

-i Run the classical interpreter.

--interp{\_}lir Run the LIR interpreter.

--interp{\_}circuit Run the circuit interpreter.

--interp{\_}prim Run the primitive circuit interpreter.

--inline Run the inlining pass before the interpreter.

-c Compile the program to a circuit.

-p Print the compiler and interpreter outputs.

-b Set the bound for a given function.

--no-prim Do not instantiate primitive circuits.

--word{\_}size Set the word size.

-help  Display this list of options

--help  Display this list of options

To quickly check that the artifact is functional, execute the interpreter on the~length~example:

{\$} ./tower -i tests/list.twr tests/length.twr tests/stack.twr tests/stack{\_}len{\_}tests.twr

Exited normally.

Functionality: Validating the Paper's Claims

The easiest way to validate the paper's claims is to do the following in the~oopsla22-artifact/~directory:

1. Ensure the interpreter~./tower~is present.

If it is not, rebuild it from source by invoking~make~(for more instructions, see the {\textquotedbl}Detailed Build Instructions{\textquotedbl} section).

2. Execute the interpreter on the data structure correctness tests by invoking~make check.

This operation should take about one minute to complete.

To evaluate the claim, verify that the output of each line is~Exited normally., indicating that the test passes.

The~tests/~directory contains a set of~.twr~programs corresponding to the benchmarks in the paper. Specifically, the programs whose name ends in~{\_}tests~contain tests for the correctness of the data structure implementations.

3. Execute the data structure performance tests using~./bench.sh.

This operation should take about three minutes to complete. A saved reference copy of the output of~./bench.shis stored in the file~bench.out.

The~./bench.sh~script lists each data structure operation from Table 1 of the paper, followed by its expected qubit and gate counts as a function of the structure size. It then computes and prints the expected and actual qubit and gate counts for the operation, instantiated at different sizes.

To evaluate the claim, verify that each line of output that compares the actual and expected qubit and gate counts states~PASS, indicating that the actual complexity matches Table 1 of the paper.

The qubit and gate counts output by~./bench.sh~will be consistent with the asymptotic complexities reported in the {\textquotedbl}Complexity{\textquotedbl} column in Table 1 of the paper, which subsume both qubit and gate complexities. For convenience, this column from the paper is reproduced below, alongside the qubit and gate counts that are output by~./bench.sh.





Paper Benchmark

Filename

Complexity (Tab. 1)

Qubits

Gates









List},
 author = {{Charles Yuan} and {Michael Carbin}},
 year = {2022},
 title = {Tower: Data Structures in Quantum Superposition},
 publisher = {Zenodo},
 doi = {10.5281/ZENODO.6819031}
}


@misc{GFB*,
 abstract = {Quantum computers promise to exceed the capabilities of conventional computers in fields such as computational chemistry, machine learning, and cryptoanalysis, thus attracting massive research interest. Currently, we distinguish between two different quantum computing applications. The first one is related to the quantum systems that are available at the present and in the near future. Such systems are characterized by a few noisy qubits and are called Noisy Intermediate-Scale Quantum (NISQ) systems. The second application, called fault-tolerant quantum computing, will allow us to run complex algorithms, such as Shor's algorithm for factorization, relying on error-correcting codes. Many of these algorithms require some classical arithmetic operations, e.g., exponential, reciprocal, square root, multiplication, squaring. The corresponding Boolean functions have to be mapped into a universal set of quantum gates, to be performed on an actual quantum computer. This mapping is part of the so-called quantum compilation process. The output of the process is a quantum circuit, which can be evaluated in terms of the resources it requires (gates and qubits).},
 author = {{Giulia Meuli} and {Fereshte Mozafari} and {Bruno Schmitt} and {Heinz Riener} and {Mathias Soeken} and {Giovanni De Micheli}},
 title = {Quantum compilation},
 keywords = {Gerneral Research;Not-citeable}
}


@article{Knil,
 abstract = {A few conventions for thinking about and writing quantum pseudocode are proposed. The conventions can be used for presenting any quantum algorithm down to the lowest level and are consistent with a quantum random access machine (QRAM) model for quantum computing. In principle a formal version of quantum pseudocode could be used in a future extension of a conventional language.},
 author = {Knill, E.},
 year = {1996},
 title = {Conventions for Quantum Pseudocode},
 url = {http://arxiv.org/pdf/2211.02559},
 journal = {LANL report LAUR-96-}
}


@inproceedings{LBZ21,
 author = {Liu, Ji and Bello, Luciano and Zhou, Huiyang},
 title = {Relaxed Peephole Optimization: A Novel Compiler Optimization for Quantum Circuits},
 pages = {301--314},
 publisher = {{IEEE Press}},
 isbn = {978-1-7281-8613-9},
 booktitle = {Proceedings of the 2021 IEEE/ACM International Symposium on Code Generation and Optimization},
 year = {2021},
 address = {[S.l.]},
 doi = {10.1109/CGO51591.2021.9370310},
 file = {lbz21 Relaxed{\_}Peephole{\_}Optimization:Attachments/lbz21 Relaxed{\_}Peephole{\_}Optimization.pdf:application/pdf}
}


@book{LuDe86,
 author = {Lutz, Christopher and Derby, Howard},
 year = {1986},
 title = {Janus: a time-reversible language},
 url = {https://tetsuo.jp/ref/janus.pdf}
}


@article{McKe65,
 author = {McKeeman, W. M.},
 year = {1965},
 title = {Peephole optimization},
 pages = {443--444},
 volume = {8},
 number = {7},
 issn = {0001-0782},
 journal = {Communications of the ACM},
 doi = {10.1145/364995.365000},
 file = {McKe65 - Peephole Optimization:Attachments/McKe65 - Peephole Optimization.pdf:application/pdf}
}


@article{MoOs,
 abstract = {In this paper we introduce the study of quantum boolean functions, which are unitary operators f whose square is the identity: f{\^{}}2 = I. We describe several generalisations of well-known results in the theory of boolean functions, including quantum property testing; a quantum version of the Goldreich-Levin algorithm for finding the large Fourier coefficients of boolean functions; and two quantum versions of a theorem of Friedgut, Kalai and Naor on the Fourier spectra of boolean functions. In order to obtain one of these generalisations, we prove a quantum extension of the hypercontractive inequality of Bonami, Gross and Beckner.},
 author = {Montanaro, Ashley and Osborne, Tobias J.},
 title = {Quantum boolean functions},
 url = {http://arxiv.org/pdf/0810.2435},
 journal = {Chicago Journal of Theoretical Computer Science vol}
}


@article{PaQu95,
 author = {Parr, T. J. and Quong, R. W.},
 year = {1995},
 title = {ANTLR: A predicated-- LL ( k ) parser generator},
 pages = {789--810},
 volume = {25},
 number = {7},
 issn = {0038-0644},
 journal = {Software: Practice and Experience},
 doi = {10.1002/spe.4380250705}
}


@inproceedings{Sark00,
 author = {Sarkar, Vivek},
 title = {Optimized unrolling of nested loops},
 pages = {153--166},
 publisher = {ACM},
 isbn = {1581132700},
 editor = {Reynders, John and Veidenbaum, Alex},
 booktitle = {Proceedings of the 14th international conference on Supercomputing},
 year = {2000},
 address = {New York, NY, USA},
 doi = {10.1145/335231.335246}
}


@incollection{TAG12,
 author = {Thomsen, Michael Kirkedal and Axelsen, Holger Bock and Gl{\"u}ck, Robert},
 title = {A Reversible Processor Architecture and Its Reversible Logic Design},
 pages = {30--42},
 volume = {7165},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-642-29516-4},
 series = {Lecture Notes in Computer Science},
 editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and {Pandu Rangan}, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and de Vos, Alexis and Wille, Robert},
 booktitle = {Reversible Computation},
 year = {2012},
 address = {Berlin, Heidelberg},
 doi = {10.1007/978-3-642-29517-1{\textunderscore }3}
}


@misc{Thomtbd,
 author = {{Thomas Noll, Christina Gehnen, Roy Hermanns}},
 date = {tbd},
 title = {Quantum Computing: From Weakest Preconditions to Voltage Pulses},
 keywords = {Pre-release},
 institution = {{Software Modelling and Verification Group, RWTH Aachen University, Germany}},
 file = {Quantum Computing (Noll):Attachments/Quantum Computing (Noll).pdf:application/pdf}
}


@misc{van20,
 abstract = {The ZX-calculus is a graphical language for reasoning about quantum computation that has recently seen an increased usage in a variety of areas such as quantum circuit optimisation, surface codes and lattice surgery, measurement-based quantum computation, and quantum foundations. The first half of this review gives a gentle introduction to the ZX-calculus suitable for those familiar with the basics of quantum computing. The aim here is to make the reader comfortable enough with the ZX-calculus that they could use it in their daily work for small computations on quantum circuits and states. The latter sections give a condensed overview of the literature on the ZX-calculus. We discuss Clifford computation and graphically prove the Gottesman-Knill theorem, we discuss a recently introduced extension of the ZX-calculus that allows for convenient reasoning about Toffoli gates, and we discuss the recent completeness theorems for the ZX-calculus that show that, in principle, all reasoning about quantum computation can be done using ZX-diagrams. Additionally, we discuss the categorical and algebraic origins of the ZX-calculus and we discuss several extensions of the language which can represent mixed states, measurement, classical control and higher-dimensional qudits.},
 author = {{van de Wetering}, John},
 date = {27.12.2020},
 title = {ZX-calculus for the working quantum computer scientist},
 url = {http://arxiv.org/pdf/2012.13966v1}
}


@article{Ying11,
 author = {Ying, Mingsheng},
 year = {2011},
 title = {Floyd--hoare logic for quantum programs},
 pages = {1--49},
 volume = {33},
 number = {6},
 issn = {0164-0925},
 journal = {ACM Transactions on Programming Languages and Systems},
 doi = {10.1145/2049706.2049708},
 file = {ying11 floyd--hoare logic:Attachments/ying11 floyd--hoare logic.pdf:application/pdf}
}


@article{YuCa22,
 author = {Yuan, Charles and Carbin, Michael},
 year = {2022},
 title = {Tower: data structures in Quantum superposition},
 pages = {259--288},
 volume = {6},
 number = {OOPSLA2},
 journal = {Proceedings of the ACM on Programming Languages},
 doi = {10.1145/3563297}
}


@article{YVC24,
 author = {Yuan, Charles and Villanyi, Agnes and Carbin, Michael},
 year = {2024},
 title = {Quantum Control Machine: The Limits of Control Flow in Quantum Programming},
 pages = {1--28},
 volume = {8},
 number = {OOPSLA1},
 journal = {Proceedings of the ACM on Programming Languages},
 doi = {10.1145/3649811}
}


@misc{YVC24b,
 abstract = {OOPSLA 2024 Artifact: Quantum Control Machine

This artifact is being submitted to support the OOPSLA'24 paper {\textquotedbl}Quantum Control Machine: The Limits of Control Flow in Quantum Programming{\textquotedbl} by Charles Yuan, Agnes Villanyi, and Michael Carbin. The artifact contains:

README.md, this document

artifact.tgz, a Docker image containing source code, pre-built binaries, and tests

A~Dockerfile~that generates the above image from scratch

The directory~qcm-artifact, a copy of the contents of the Docker image, containing the source code of the simulator (src/) and the tests (test/)

The contents of this artifact are also available on~GitHub.

Kick-the-Tires: Getting Started with the Artifact

First, import~artifact.tgz~into Docker. In our testing, we used Docker Engine 24.0.6 on macOS Sonoma. The image may be loaded using the following commands:

{\$} docker load {\textless} artifact.tgz

Loaded image: qcm-artifact:latest

{\$} docker run -it --rm qcm-artifact bash

opam@502e0da78017:{\~{}}/qcm-artifact{\$}

The artifact is in the~qcm-artifact/~directory inside the user home directory. To quickly check that the artifact is functional, execute the following command and check that the output displays~state is synchronized:

{\$} cd {\~{}}/qcm-artifact/

{\$} ./qcm -r {\textquotedbl}x=3,y=0{\textquotedbl} -t 5 test/addition.qcm

(1.000000 + 0.000000i) |pc:7,br:1,x:3,y:3{\textgreater}

state is synchronized

Functionality: Validating the Paper's Claims

This artifact supports the following claim from Section 6 of the paper:

We have implemented a simulator for the quantum control machine, which accepts a program, input, and runtime~t, and outputs the machine state after~t~steps. Implementations of all case study examples as executable programs are also packaged with the simulator.

The easiest way to validate the claim is to do the following in the~qcm-artifact/~directory. First, ensure the simulator~./qcm~is present. If it is not, rebuild it from source by invoking~make~(for more instructions, see {\textquotedbl}Detailed Build Instructions{\textquotedbl} below).

Second, execute the simulator on all provided test programs by invoking~make check. This operation should take about one second to complete.

Finally, check that the output of~make check~is identical to the contents of the file~expected{\_}output. Specifically, the message~state is synchronized~should appear for all programs except~test/exponentiation-nosync.qcm, which should output~state is not synchronized.

Each example program for the quantum control machine presented in the paper corresponds to a program in the~test/~directory:

Figure 2 in the paper corresponds to~test/addition.qcm.

Figure 6 in the paper corresponds to~test/exponentiation-nosync.qcm.

Figure 7 in the paper corresponds to~test/exponentiation.qcm.

Figure 8 in the paper corresponds to~test/hadamard.qcm.

Figure 10 in the paper corresponds to~test/majorana.qcm.

As a technical note, the paper presents each program using named labels (e.g.~l1:). By contrast, the formal language specification in Table 1 of the paper, as well as this artifact, use explicit line offsets (e.g.~{\$}+3) rather than labels. For each program, we have provided the version with named labels as seen in the paper in a file suffixed~-labels, e.g.~test/addition-labels.qcm. We have also provided a simple script~label2offset.py~that can be used to convert named labels to explicit line offsets. One may convert~test/addition-labels.qcm~to~test/addition.qcm~by running:

./label2offset.py {\textless} test/addition-labels.qcm {\textgreater} test/addition.qcm

Reusability: Writing Programs

The simulator included in the artifact makes it possible to write new programs and extend the functionality of the simulator. The file~src/README.md~describes the organization of the simulator sources, should you wish to modify the code.

To execute a program, supply it as an argument to the simulator, for example:

{\$} ./qcm -r {\textquotedbl}x=3,y=0{\textquotedbl} -t 5 test/addition.qcm

(1.000000 + 0.000000i) |pc:7,br:1,x:3,y:3{\textgreater}

state is synchronized

{\$} ./qcm -r {\textquotedbl}res=0,r1=0,x=2,y=1{\textquotedbl} -r {\textquotedbl}res=0,r1=0,x=2,y=2{\textquotedbl} -t 10 test/exponentiation-nosync.qcm

(0.707107 + 0.000000i) |pc:5,br:1,res:4,r1:1,y:2,x:2{\textgreater} + (0.707107 + 0.000000i) |pc:8,br:1,res:2,r1:0,y:1,x:2{\textgreater}

state is not synchronized

The~-t~flag specifies the number of steps to execute. The~-r~flag specifies the initial register state, a comma-separated list of variable names and values separated by~=. Specifying multiple instances of~-r~initializes the register state to the uniform superposition of the specified states.

The output of the simulator is the final state of the machine, which is a complex vector of amplitudes and register states. The simulator also outputs whether the state is synchronized or not, i.e. whether the values of~pc~and~br~are equal across all states in the final superposition.

To see examples of programs and invocations, see the~test/~directory and the~Makefile. To see the full list of options, run:

./qcm --help

Detailed Build Instructions

In the provided image, simply run~make~within~qcm-artifact~to build the simulator from source.

To build the simulator outside of the image, first install OCaml version 5.0.0 with~dune~and the libraries~core,~menhir, and~ppx{\_}deriving. The recommended way to install OCaml and the dependent libraries is via~OPAM. Then, to build the simulator~./qcm, simply run~make.},
 author = {Yuan, Charles and Villanyi, Agnes and Carbin, Michael},
 year = {2024},
 title = {Quantum Control Machine: The Limits of Control Flow in Quantum Programming},
 publisher = {Zenodo},
 doi = {10.5281/ZENODO.10452601}
}


@misc{YYF12,
 abstract = {A remarkable difference between quantum and classical programs is that the control flow of the former can be either classical or quantum. One of the key issues in the theory of quantum programming languages is defining and understanding quantum control flow. A functional language with quantum control flow was defined by Altenkirch and Grattage [\textit{Proc. LICS'05}, pp. 249-258]. This paper extends their work, and we introduce a general quantum control structure by defining three new quantum program constructs, namely quantum guarded command, quantum choice and quantum recursion. We clarify the relation between quantum choices and probabilistic choices. An interesting difference between quantum recursions with classical control flows and with quantum control flows is revealed.},
 author = {Ying, Mingsheng and Yu, Nengkun and Feng, Yuan},
 date = {19.09.2012},
 title = {Defining Quantum Control Flow},
 url = {http://arxiv.org/pdf/1209.4379v1}
}


@article{ZRK*11,
 abstract = {Although quantum computers promise significant advantages, the complexity of quantum algorithms remains a major technological obstacle. We have developed and demonstrated an architecture-independent technique that simplifies adding control qubits to arbitrary quantum operations-a requirement in many quantum algorithms, simulations and metrology. The technique, which is independent of how the operation is done, does not require knowledge of what the operation is, and largely separates the problems of how to implement a quantum operation in the laboratory and how to add a control. Here, we demonstrate an entanglement-based version in a photonic system, realizing a range of different two-qubit gates with high fidelity.},
 author = {Zhou, Xiao-Qi and Ralph, Timothy C. and Kalasuwan, Pruet and Zhang, Mian and Peruzzo, Alberto and Lanyon, Benjamin P. and O'Brien, Jeremy L.},
 year = {2011},
 title = {Adding control to arbitrary unknown quantum operations},
 url = {https://www.nature.com/articles/ncomms1392},
 pages = {413},
 volume = {2},
 number = {1},
 issn = {2041-1723},
 journal = {Nature Communications},
 doi = {10.1038/ncomms1392}
}


