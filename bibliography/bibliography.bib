% This file was created with Citavi 6.19.2.1

@book{74,
 year = {1974},
 title = {Compiler Construction},
 address = {Berlin, Heidelberg},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-540-06958-4},
 series = {Lecture Notes in Computer Science},
 editor = {Bauer, F. L. and de Remer, F. L. and Griffiths, M. and Hill, U. and Horning, J. J. and Koster, C. H. A. and McKeeman, W. M. and Poole, P. C. and Waite, W. M. and Eickel, J.},
 doi = {10.1007/978-3-662-21549-4}
}


@article{ACR*10,
 author = {Ambainis, A. and Childs, A. M. and Reichardt, B. W. and {\v{S}}palek, R. and Zhang, S.},
 year = {2010},
 title = {Any AND-OR Formula of Size N Can Be Evaluated in Time {\$}N{\^{}}{1/2+o(1)}{\$} on a Quantum Computer},
 pages = {2513--2530},
 volume = {39},
 number = {6},
 issn = {0097-5397},
 journal = {SIAM Journal on Computing},
 doi = {10.1137/080712167}
}


@incollection{AGY07,
 author = {Axelsen, Holger Bock and Gl{\"u}ck, Robert and Yokoyama, Tetsuo},
 title = {Reversible Machine Code and Its Abstract Processor Architecture},
 pages = {56--69},
 volume = {4649},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-540-74509-9},
 series = {Lecture Notes in Computer Science},
 editor = {Diekert, Volker and Volkov, Mikhail V. and Voronkov, Andrei},
 booktitle = {Computer Science -- Theory and Applications},
 year = {2007},
 address = {Berlin, Heidelberg},
 doi = {10.1007/978-3-540-74510-5{\textunderscore }9}
}


@inproceedings{AlGr05,
 abstract = {We introduce the language QML, a functional language for quantum computations on finite types. Its design is guided by its categorical semantics: QML programs are interpreted by morphisms in the category FQC of finite quantum computations, which provides a constructive semantics of irreversible quantum computations realisable as quantum gates. QML integrates reversible and irreversible quantum computations in one language, using first order strict linear logic to make weakenings explicit. Strict programs are free from decoherence and hence preserve superpositions and entanglement -which is essential for quantum parallelism.},
 author = {Altenkirch, T. and Grattage, J.},
 title = {A Functional Quantum Programming Language},
 pages = {249--258},
 publisher = {IEEE},
 isbn = {0-7695-2266-1},
 booktitle = {20th Annual IEEE Symposium on Logic in Computer Science (LICS' 05)},
 year = {2005},
 doi = {10.1109/LICS.2005.1}
}


@incollection{Axel11,
 author = {Axelsen, Holger Bock},
 title = {Clean Translation of an Imperative Reversible Programming Language},
 pages = {144--163},
 volume = {6601},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-642-19860-1},
 series = {Lecture Notes in Computer Science},
 editor = {Knoop, Jens},
 booktitle = {Compiler Construction},
 year = {2011},
 address = {Berlin, Heidelberg},
 doi = {10.1007/978-3-642-19861-8{\textunderscore }9}
}


@incollection{AxGl11,
 author = {Axelsen, Holger Bock and Gl{\"u}ck, Robert},
 title = {What Do Reversible Programs Compute?},
 pages = {42--56},
 volume = {6604},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-642-19804-5},
 series = {Lecture Notes in Computer Science},
 editor = {Hofmann, Martin},
 booktitle = {Foundations of Software Science and Computational Structures},
 year = {2011},
 address = {Berlin, Heidelberg},
 doi = {10.1007/978-3-642-19805-2{\textunderscore }4}
}


@article{BAAM20,
 abstract = {Every quantum algorithm is represented by set of quantum circuits. Any optimization scheme for a quantum algorithm and quantum computation is very important especially in the arena of quantum computation with limited number of qubit resources. Major obstacle to this goal is the large number of elemental quantum gates to build even small quantum circuits. Here, we propose and demonstrate a general technique that significantly reduces the number of elemental gates to build quantum circuits. This is impactful for the design of quantum circuits, and we show below this could reduce the number of gates by 60{\%} and 46{\%} for the four- and five-qubit Toffoli gates, two key quantum circuits, respectively, as compared with simplest known decomposition. Reduced circuit complexity often goes hand-in-hand with higher efficiency and bandwidth. The quantum circuit optimization technique proposed in this work would provide a significant step forward in the optimization of quantum circuits and quantum algorithms, and has the potential for wider application in quantum computation.},
 author = {Bae, J-H and Alsing, Paul M. and Ahn, Doyeol and Miller, Warner A.},
 year = {2020},
 title = {Quantum circuit optimization using quantum Karnaugh map},
 pages = {15651},
 volume = {10},
 number = {1},
 journal = {Scientific reports},
 doi = {10.1038/s41598-020-72469-7}
}


@inproceedings{BBGV20,
 author = {Bichsel, Benjamin and Baader, Maximilian and Gehr, Timon and Vechev, Martin},
 title = {Silq: a high-level quantum language with safe uncomputation and intuitive semantics},
 pages = {286--300},
 publisher = {ACM},
 isbn = {9781450376136},
 editor = {Donaldson, Alastair F. and Torlak, Emina},
 booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
 year = {2020},
 address = {New York, NY, USA},
 doi = {10.1145/3385412.3386007}
}


@incollection{BeDa94,
 author = {Benitez, Manuel E. and Davidson, Jack W.},
 title = {The advantages of machine-dependent global optimization},
 pages = {105--124},
 volume = {782},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-540-57840-6},
 series = {Lecture Notes in Computer Science},
 editor = {Goos, Gerhard and Hartmanis, Juris and Gutknecht, J{\"u}rg},
 booktitle = {Programming Languages and System Architectures},
 year = {1994},
 address = {Berlin, Heidelberg},
 doi = {10.1007/3-540-57840-4{\textunderscore }27}
}


@article{BeLa17,
 abstract = {Cryptography is essential for the security of online communication, cars and implanted medical devices. However, many commonly used cryptosystems will be completely broken once large quantum computers exist. Post-quantum cryptography is cryptography under the assumption that the attacker has a large quantum computer; post-quantum cryptosystems strive to remain secure even in this scenario. This relatively young research area has seen some successes in identifying mathematical operations for which quantum algorithms offer little advantage in speed, and then building cryptographic systems around those. The central challenge in post-quantum cryptography is to meet demands for cryptographic usability and flexibility without sacrificing confidence.},
 author = {Bernstein, Daniel J. and Lange, Tanja},
 year = {2017},
 title = {Post-quantum cryptography},
 pages = {188--194},
 volume = {549},
 number = {7671},
 journal = {Nature},
 doi = {10.1038/nature23461}
}


@inproceedings{BeVa93,
 author = {Bernstein, Ethan and Vazirani, Umesh},
 title = {Quantum complexity theory},
 pages = {11--20},
 publisher = {{ACM Press}},
 isbn = {0897915917},
 editor = {Kosaraju, Rao and Johnson, David and Aggarwal, Alok},
 booktitle = {Proceedings of the twenty-fifth annual ACM symposium on Theory of computing  - STOC '93},
 year = {1993},
 address = {New York, New York, USA},
 doi = {10.1145/167088.167097}
}


@inproceedings{BFA22,
 author = {Bandic, Medina and Feld, Sebastian and Almudever, Carmen G.},
 title = {Full-stack quantum computing systems in the NISQ era: algorithm-driven and hardware-aware compilation techniques},
 pages = {1--6},
 publisher = {{European Design and Automation Association}},
 isbn = {978-3-9819263-6-1},
 series = {ACM Conferences},
 editor = {Bolchini, Cristiana},
 booktitle = {Proceedings of the 2022 Conference et Exhibition on Design, Automation et Test in Europe},
 year = {2022},
 address = {Leuven,Belgium},
 doi = {10.23919/DATE54114.2022.9774643}
}


@article{BGB*18,
 author = {Babbush, Ryan and Gidney, Craig and Berry, Dominic W. and Wiebe, Nathan and McClean, Jarrod and Paler, Alexandru and Fowler, Austin and Neven, Hartmut},
 year = {2018},
 title = {Encoding Electronic Spectra in Quantum Circuits with Linear T Complexity},
 volume = {8},
 number = {4},
 journal = {Physical Review X},
 doi = {10.1103/PhysRevX.8.041015}
}


@article{BML,
 abstract = {In this paper we review main ideas mentioned in several other papers which talk about optimization techniques used by compilers. Here we focus on loop unrolling technique and its effect on power consumption, energy usage and also its impact on program speed up by achieving ILP (Instruction-level parallelism). Concentrating on superscalar processors, we discuss the idea of generalized loop unrolling presented by J.C. Hang and T. Leng and then we present a new method to traverse a linked list to get a better result of loop unrolling in that case. After that we mention the results of some experiments carried out on a Pentium 4 processor (as an instance of super scalar architecture). Furthermore, the results of some other experiments on supercomputer (the Alliat FX/2800 System) containing superscalar node processors would be mentioned. These experiments show that loop unrolling has a slight measurable effect on energy usage as well as power consumption. But it could be an effective way for program speed up.},
 author = {Booshehri, Meisam and Malekpour, Abbas and Luksch, Peter},
 title = {An Improving Method for Loop Unrolling},
 url = {http://arxiv.org/pdf/1308.0698},
 volume = {11},
 number = {5},
 journal = {International Journal of Computer Science and Information Security, Vol. 11, No. 5, pp. 73-76}
}


@misc{BMTM20,
 abstract = {Artifact for PLDI'20 paper {\textquotedbl}Silq: A High-level Quantum Programming Language with Safe Uncomputation and Intuitive Semantics{\textquotedbl}.},
 author = {{Benjamin Bichsel} and {Maximilian Baader} and {Timon Gehr} and {Martin Vechev}},
 year = {2020},
 title = {tgehr/silq-artifact: PLDI'20 artifact},
 publisher = {Zenodo},
 doi = {10.5281/zenodo.3764961}
}


@misc{BrBr01,
 abstract = {In this paper we study universality for quantum gates acting on qudits.Qudits are states in a Hilbert space of dimension d where d is at least two. We determine which 2-qudit gates V have the properties (i) the collection of all 1-qudit gates together with V produces all n-qudit gates up to arbitrary precision, or (ii) the collection of all 1-qudit gates together with V produces all n-qudit gates exactly. We show that (i) and (ii) are equivalent conditions on V, and they hold if and only if V is not a primitive gate. Here we say V is primitive if it transforms any decomposable tensor into a decomposable tensor. We discuss some applications and also relations with work of other authors.

10 pages, Latex},
 author = {Brylinski, Jean-Luc and Brylinski, Ranee},
 date = {2001},
 title = {Universal quantum gates},
 publisher = {arXiv},
 doi = {10.48550/arXiv.quant-ph/0108062}
}


@misc{CBSG17,
 abstract = {This document describes a quantum assembly language (QASM) called OpenQASM that is used to implement experiments with low depth quantum circuits. OpenQASM represents universal physical circuits over the CNOT plus SU(2) basis with straight-line code that includes measurement, reset, fast feedback, and gate subroutines. The simple text language can be written by hand or by higher level tools and may be executed on the IBM Q Experience.},
 author = {Cross, Andrew W. and Bishop, Lev S. and Smolin, John A. and Gambetta, Jay M.},
 date = {11.07.2017},
 title = {Open Quantum Assembly Language},
 url = {http://arxiv.org/pdf/1707.03429}
}


@article{CFM17,
 abstract = {Quantum computing sits at an important inflection point. For years, high-level algorithms for quantum computers have shown considerable promise, and recent advances in quantum device fabrication offer hope of utility. A gap still exists, however, between the hardware size and reliability requirements of quantum computing algorithms and the physical machines foreseen within the next ten years. To bridge this gap, quantum computers require appropriate software to translate and optimize applications (toolflows) and abstraction layers. Given the stringent resource constraints in quantum computing, information passed between layers of software and implementations will differ markedly from in classical computing. Quantum toolflows must expose more physical details between layers, so the challenge is to find abstractions that expose key details while hiding enough complexity.},
 author = {Chong, Frederic T. and Franklin, Diana and Martonosi, Margaret},
 year = {2017},
 title = {Programming languages and compiler design for realistic quantum hardware},
 pages = {180--187},
 volume = {549},
 number = {7671},
 journal = {Nature},
 doi = {10.1038/nature23459}
}


@misc{ChMi22,
 abstract = {OOPSLA 2022 Artifact: Tower

This artifact is being submitted to support the OOPSLA'22 paper {\textquotedbl}Tower: Data Structures in Quantum Superposition{\textquotedbl} by Charles Yuan and Michael Carbin. The artifact contains:

README.md, this document

tower.tgz, a Docker image containing source code, pre-built binaries, and tests

tower.dockerfile, a Dockerfile that generates the above image from scratch

The directory~oopsla22-artifact, a copy of the contents of the Docker image, containing the source code of the Tower language interpreter (src/) and the tests (tests/)

This document describes:

The claims of the paper this artifact supports

The kick-the-tires instructions for reviewers

How to review the artifact for functionality

How to review the artifact for reusability

Detailed instructions for building the artifact

The contents of this artifact, and the sources of the Tower programming language, are available on~{\textless}a href={\textquotedbl}https://github.com/psg-mit/tower-oopsla22{\textquotedbl}{\textgreater}GitHub.

Claims Supported by Artifact

This artifact supports the following claims of the paper:

(Section 7) We implemented an interpreter for Tower in OCaml that classically executes the operational semantics of the language.

This claim is evaluated by Step 2 of the section {\textquotedbl}Validating the Paper's Claims{\textquotedbl} below. The artifact provides the source code of the Tower interpreter and a suite of test cases (from Table 1 of the paper) that the interpreter can execute.

(Section 8) We implemented Ground, a library of abstract data structures in Tower, and tested its operations with the interpreter.

This claim is evaluated by Steps 2 and 3 of the section {\textquotedbl}Validating the Paper's Claims{\textquotedbl} below. The artifact provides the source code of the Ground library, including all operations described in Table 1 of the paper, and a suite of tests for the correctness of the implementation that can be executed with the provided interpreter. The artifact also includes a script that validates the complexities of the data structure operations indicated by the {\textquotedbl}Complexity{\textquotedbl} column in Table 1 of the paper.

Kick-the-Tires: Getting Started with the Artifact

First, import~tower.tgz~into Docker. In our testing, we used Docker Engine 20.10.17 on macOS Monterey. The image may be loaded using the following commands:

{\$} docker load {\textless} tower.tgz

Loaded image: oopsla22-artifact:latest

{\$} docker run -it --rm oopsla22-artifact bash

opam@502e0da78017:{\~{}}/oopsla22-artifact{\$}

The artifact is in the~oopsla22-artifact/~directory inside the user home directory, inside which the interpreter for Tower is already installed as~./tower.

{\$} cd {\~{}}/oopsla22-artifact/

{\$} ./tower -help

The interpreter for the Tower quantum programming language.

Usage: ./tower  [program]

Options are:

-v Run in verbose mode.

-i Run the classical interpreter.

--interp{\_}lir Run the LIR interpreter.

--interp{\_}circuit Run the circuit interpreter.

--interp{\_}prim Run the primitive circuit interpreter.

--inline Run the inlining pass before the interpreter.

-c Compile the program to a circuit.

-p Print the compiler and interpreter outputs.

-b Set the bound for a given function.

--no-prim Do not instantiate primitive circuits.

--word{\_}size Set the word size.

-help  Display this list of options

--help  Display this list of options

To quickly check that the artifact is functional, execute the interpreter on the~length~example:

{\$} ./tower -i tests/list.twr tests/length.twr tests/stack.twr tests/stack{\_}len{\_}tests.twr

Exited normally.

Functionality: Validating the Paper's Claims

The easiest way to validate the paper's claims is to do the following in the~oopsla22-artifact/~directory:

1. Ensure the interpreter~./tower~is present.

If it is not, rebuild it from source by invoking~make~(for more instructions, see the {\textquotedbl}Detailed Build Instructions{\textquotedbl} section).

2. Execute the interpreter on the data structure correctness tests by invoking~make check.

This operation should take about one minute to complete.

To evaluate the claim, verify that the output of each line is~Exited normally., indicating that the test passes.

The~tests/~directory contains a set of~.twr~programs corresponding to the benchmarks in the paper. Specifically, the programs whose name ends in~{\_}tests~contain tests for the correctness of the data structure implementations.

3. Execute the data structure performance tests using~./bench.sh.

This operation should take about three minutes to complete. A saved reference copy of the output of~./bench.shis stored in the file~bench.out.

The~./bench.sh~script lists each data structure operation from Table 1 of the paper, followed by its expected qubit and gate counts as a function of the structure size. It then computes and prints the expected and actual qubit and gate counts for the operation, instantiated at different sizes.

To evaluate the claim, verify that each line of output that compares the actual and expected qubit and gate counts states~PASS, indicating that the actual complexity matches Table 1 of the paper.

The qubit and gate counts output by~./bench.sh~will be consistent with the asymptotic complexities reported in the {\textquotedbl}Complexity{\textquotedbl} column in Table 1 of the paper, which subsume both qubit and gate complexities. For convenience, this column from the paper is reproduced below, alongside the qubit and gate counts that are output by~./bench.sh.





Paper Benchmark

Filename

Complexity (Tab. 1)

Qubits

Gates









List},
 author = {{Charles Yuan} and {Michael Carbin}},
 year = {2022},
 title = {Tower: Data Structures in Quantum Superposition},
 publisher = {Zenodo},
 doi = {10.5281/ZENODO.6819031}
}


@article{CJA*22,
 author = {Cross, Andrew and Javadi-Abhari, Ali and Alexander, Thomas and de Beaudrap, Niel and Bishop, Lev S. and Heidel, Steven and Ryan, Colm A. and Sivarajah, Prasahnt and Smolin, John and Gambetta, Jay M. and Johnson, Blake R.},
 year = {2022},
 title = {OpenQASM 3: A Broader and Deeper Quantum Assembly Language},
 pages = {1--50},
 volume = {3},
 number = {3},
 issn = {2643-6809},
 journal = {ACM Transactions on Quantum Computing},
 doi = {10.1145/3505636}
}


@misc{Copp02,
 abstract = {We define an approximate version of the Fourier transform on {\$}2{\^{}}L{\$} elements, which is computationally attractive in a certain setting, and which may find application to the problem of factoring integers with a quantum computer as is currently under investigation by Peter Shor. (1994 IBM Internal Report)},
 author = {Coppersmith, D.},
 date = {2002},
 title = {An approximate Fourier transform useful in quantum factoring},
 publisher = {arXiv},
 doi = {10.48550/arXiv.quant-ph/0201067}
}


@book{DC20,
 author = {Ding, Yongshan and Chong, Frederic T.},
 year = {2020},
 title = {Quantum Computer Systems},
 address = {Cham},
 publisher = {{Springer International Publishing}},
 isbn = {978-3-031-00637-1},
 doi = {10.1007/978-3-031-01765-0}
}


@article{DeJo92,
 author = {Deutsch, David and Jozsa, Richard},
 year = {1992},
 title = {Rapid solution of problems by quantum computation},
 pages = {553--558},
 volume = {439},
 number = {1907},
 issn = {0962-8444},
 journal = {Proceedings of the Royal Society of London. Series A: Mathematical and Physical Sciences},
 doi = {10.1098/rspa.1992.0167}
}


@incollection{DeRe74,
 author = {DeRemer, Franklin L.},
 title = {Lexical Analysis},
 pages = {109--120},
 volume = {21},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-540-06958-4},
 series = {Lecture Notes in Computer Science},
 editor = {Bauer, F. L. and de Remer, F. L. and Griffiths, M. and Hill, U. and Horning, J. J. and Koster, C. H. A. and McKeeman, W. M. and Poole, P. C. and Waite, W. M. and Eickel, J.},
 booktitle = {Compiler Construction},
 year = {1974},
 address = {Berlin, Heidelberg},
 doi = {10.1007/978-3-662-21549-4{\textunderscore }5}
}


@incollection{DiCh20,
 author = {Ding, Yongshan and Chong, Frederic T.},
 title = {Think Quantumly About Computing},
 pages = {13--54},
 publisher = {{Springer International Publishing}},
 isbn = {978-3-031-00637-1},
 series = {Synthesis Lectures on Computer Architecture},
 editor = {Ding, Yongshan and Chong, Frederic T.},
 booktitle = {Quantum Computer Systems},
 year = {2020},
 address = {Cham},
 doi = {10.1007/978-3-031-01765-0{\textunderscore }2}
}


@incollection{DiCh20b,
 author = {Ding, Yongshan and Chong, Frederic T.},
 title = {Introduction},
 pages = {3--12},
 publisher = {{Springer International Publishing}},
 isbn = {978-3-031-00637-1},
 series = {Synthesis Lectures on Computer Architecture},
 editor = {Ding, Yongshan and Chong, Frederic T.},
 booktitle = {Quantum Computer Systems},
 year = {2020},
 address = {Cham},
 doi = {10.1007/978-3-031-01765-0{\textunderscore }1}
}


@incollection{DiCh20c,
 author = {Ding, Yongshan and Chong, Frederic T.},
 title = {Quantum Application Design},
 pages = {55--70},
 publisher = {{Springer International Publishing}},
 isbn = {978-3-031-00637-1},
 series = {Synthesis Lectures on Computer Architecture},
 editor = {Ding, Yongshan and Chong, Frederic T.},
 booktitle = {Quantum Computer Systems},
 year = {2020},
 address = {Cham},
 doi = {10.1007/978-3-031-01765-0{\textunderscore }3}
}


@article{Dijk75,
 author = {Dijkstra, Edsger W.},
 year = {1975},
 title = {Guarded commands, nondeterminacy and formal derivation of programs},
 pages = {453--457},
 volume = {18},
 number = {8},
 issn = {0001-0782},
 journal = {Communications of the ACM},
 doi = {10.1145/360933.360975}
}


@article{DMN13,
 abstract = {Quantum error correction (QEC) and fault-tolerant quantum computation represent one of the most vital theoretical aspects of quantum information processing. It was well known from the early developments of this exciting field that the fragility of coherent quantum systems would be a catastrophic obstacle to the development of large-scale quantum computers. The introduction of quantum error correction in 1995 showed that active techniques could be employed to mitigate this fatal problem. However, quantum error correction and fault-tolerant computation is now a much larger field and many new codes, techniques, and methodologies have been developed to implement error correction for large-scale quantum algorithms. In response, we have attempted to summarize the basic aspects of quantum error correction and fault-tolerance, not as a detailed guide, but rather as a basic introduction. The development in this area has been so pronounced that many in the field of quantum information, specifically researchers who are new to quantum information or people focused on the many other important issues in quantum computation, have found it difficult to keep up with the general formalisms and methodologies employed in this area. Rather than introducing these concepts from a rigorous mathematical and computer science framework, we instead examine error correction and fault-tolerance largely through detailed examples, which are more relevant to experimentalists today and in the near future.},
 author = {Devitt, Simon J. and Munro, William J. and Nemoto, Kae},
 year = {2013},
 title = {Quantum error correction for beginners},
 pages = {076001},
 volume = {76},
 number = {7},
 journal = {Reports on progress in physics. Physical Society (Great Britain)},
 doi = {10.1088/0034-4885/76/7/076001}
}


@misc{Drap00,
 abstract = {A new method for computing sums on a quantum computer is introduced. This technique uses the quantum Fourier transform and reduces the number of qubits necessary for addition by removing the need for temporary carry bits. This approach also allows the addition of a classical number to a quantum superposition without encoding the classical number in the quantum register. This method also allows for massive parallelization in its execution.

8 pages, 5 figures},
 author = {Draper, Thomas G.},
 date = {2000},
 title = {Addition on a Quantum Computer},
 publisher = {arXiv},
 doi = {10.48550/arXiv.quant-ph/0008033}
}


@misc{FNML21,
 abstract = {A central aspect for operating future quantum computers is quantum circuit optimization, i.e., the search for efficient realizations of quantum algorithms given the device capabilities. In recent years, powerful approaches have been developed which focus on optimizing the high-level circuit structure. However, these approaches do not consider and thus cannot optimize for the hardware details of the quantum architecture, which is especially important for near-term devices. To address this point, we present an approach to quantum circuit optimization based on reinforcement learning. We demonstrate how an agent, realized by a deep convolutional neural network, can autonomously learn generic strategies to optimize arbitrary circuits on a specific architecture, where the optimization target can be chosen freely by the user. We demonstrate the feasibility of this approach by training agents on 12-qubit random circuits, where we find on average a depth reduction by 27{\%} and a gate count reduction by 15{\%}. We examine the extrapolation to larger circuits than used for training, and envision how this approach can be utilized for near-term quantum devices.},
 author = {F{\"o}sel, Thomas and Niu, Murphy Yuezhen and Marquardt, Florian and Li, Li},
 date = {13.03.2021},
 title = {Quantum circuit optimization with deep reinforcement learning},
 url = {http://arxiv.org/pdf/2103.07585v1}
}


@incollection{FYY13,
 author = {Feng, Yuan and Yu, Nengkun and Ying, Mingsheng},
 title = {Reachability Analysis of Recursive Quantum Markov Chains},
 pages = {385--396},
 volume = {8087},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-642-40312-5},
 series = {Lecture Notes in Computer Science},
 editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and {Pandu Rangan}, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Chatterjee, Krishnendu and Sgall, Jir{\'i}},
 booktitle = {Mathematical Foundations of Computer Science 2013},
 year = {2013},
 address = {Berlin, Heidelberg},
 doi = {10.1007/978-3-642-40313-2{\textunderscore }35}
}


@misc{GaCh11,
 abstract = {Quantum algorithms and protocols are often presented as quantum circuits for a better understanding. We give a list of equivalence rules which can help in the analysis and design of quantum circuits. As example applications we study quantum teleportation and dense coding protocols in terms of a simple XOR swapping circuit and give an intuitive picture of a basic gate teleportation circuit.},
 author = {Garcia-Escartin, Juan Carlos and Chamorro-Posada, Pedro},
 date = {13.10.2011},
 title = {Equivalent Quantum Circuits},
 url = {http://arxiv.org/pdf/1110.2998v1}
}


@misc{GFB*,
 abstract = {Quantum computers promise to exceed the capabilities of conventional computers in fields such as computational chemistry, machine learning, and cryptoanalysis, thus attracting massive research interest. Currently, we distinguish between two different quantum computing applications. The first one is related to the quantum systems that are available at the present and in the near future. Such systems are characterized by a few noisy qubits and are called Noisy Intermediate-Scale Quantum (NISQ) systems. The second application, called fault-tolerant quantum computing, will allow us to run complex algorithms, such as Shor's algorithm for factorization, relying on error-correcting codes. Many of these algorithms require some classical arithmetic operations, e.g., exponential, reciprocal, square root, multiplication, squaring. The corresponding Boolean functions have to be mapped into a universal set of quantum gates, to be performed on an actual quantum computer. This mapping is part of the so-called quantum compilation process. The output of the process is a quantum circuit, which can be evaluated in terms of the resources it requires (gates and qubits).},
 author = {{Giulia Meuli} and {Fereshte Mozafari} and {Bruno Schmitt} and {Heinz Riener} and {Mathias Soeken} and {Giovanni De Micheli}},
 title = {Quantum compilation},
 keywords = {Gerneral Research;Not-citeable}
}


@article{GFH82,
 author = {Ganapathi, Mahadevan and Fischer, Charles N. and Hennessy, John L.},
 year = {1982},
 title = {Retargetable Compiler Code Generation},
 pages = {573--592},
 volume = {14},
 number = {4},
 issn = {0360-0300},
 journal = {ACM Computing Surveys},
 doi = {10.1145/356893.356897}
}


@incollection{Gref99,
 author = {Grefenstette, Gregory},
 title = {Tokenization},
 pages = {117--133},
 volume = {9},
 publisher = {{Springer Netherlands}},
 isbn = {978-90-481-5296-4},
 series = {Text, Speech and Language Technology},
 editor = {Ide, Nancy and V{\'e}ronis, Jean and {van Halteren}, Hans},
 booktitle = {Syntactic Wordclass Tagging},
 year = {1999},
 address = {Dordrecht},
 doi = {10.1007/978-94-015-9273-4{\textunderscore }9}
}


@article{HHHH09,
 author = {Horodecki, Ryszard and Horodecki, Pawe{\l} and Horodecki, Micha{\l} and Horodecki, Karol},
 year = {2009},
 title = {Quantum entanglement},
 pages = {865--942},
 volume = {81},
 number = {2},
 issn = {0034-6861},
 journal = {Reviews of Modern Physics},
 doi = {10.1103/RevModPhys.81.865}
}


@misc{Jozs05,
 abstract = {In the formalism of measurement based quantum computation we start with a given fixed entangled state of many qubits and perform computation by applying a sequence of measurements to designated qubits in designated bases. The choice of basis for later measurements may depend on earlier measurement outcomes and the final result of the computation is determined from the classical data of all the measurement outcomes. This is in contrast to the more familiar gate array model in which computational steps are unitary operations, developing a large entangled state prior to some final measurements for the output. Two principal schemes of measurement based computation are teleportation quantum computation (TQC) and the so-called cluster model or one-way quantum computer (1WQC). We will describe these schemes and show how they are able to perform universal quantum computation. We will outline various possible relationships between the models which serve to clarify their workings. We will also discuss possible novel computational benefits of the measurement based models compared to the gate array model, especially issues of parallelisability of algorithms.

22 pages, 15 figures. Section 6.2 replaced},
 author = {Jozsa, Richard},
 date = {2005},
 title = {An introduction to measurement based quantum computation},
 publisher = {arXiv},
 doi = {10.48550/arXiv.quant-ph/0508124}
}


@article{KlMa13,
 author = {Kliuchnikov, Vadym and Maslov, Dmitri},
 year = {2013},
 title = {Optimization of Clifford circuits},
 volume = {88},
 number = {5},
 issn = {1050-2947},
 journal = {Physical Review A},
 doi = {10.1103/PhysRevA.88.052307}
}


@article{KMO*23,
 author = {Kreppel, Fabian and Melzer, Christian and {Olvera Mill{\'a}n}, Diego and Wagner, Janis and Hilder, Janine and Poschinger, Ulrich and Schmidt-Kaler, Ferdinand and Brinkmann, Andr{\'e}},
 year = {2023},
 title = {Quantum Circuit Compiler for a Shuttling-Based Trapped-Ion Quantum Computer},
 pages = {1176},
 volume = {7},
 journal = {Quantum},
 doi = {10.22331/q-2023-11-08-1176}
}


@article{Knil,
 abstract = {A few conventions for thinking about and writing quantum pseudocode are proposed. The conventions can be used for presenting any quantum algorithm down to the lowest level and are consistent with a quantum random access machine (QRAM) model for quantum computing. In principle a formal version of quantum pseudocode could be used in a future extension of a conventional language.},
 author = {Knill, E.},
 year = {1996},
 title = {Conventions for Quantum Pseudocode},
 url = {http://arxiv.org/pdf/2211.02559},
 journal = {LANL report LAUR-96-}
}


@article{KuBr00,
 author = {{Kumar Pati}, Arun and Braunstein, Samuel L.},
 year = {2000},
 title = {Impossibility of deleting an unknown quantum state},
 pages = {164--165},
 volume = {404},
 number = {6774},
 journal = {Nature},
 doi = {10.1038/404130b0}
}


@article{Land61,
 author = {Landauer, R.},
 year = {1961},
 title = {Irreversibility and Heat Generation in the Computing Process},
 pages = {183--191},
 volume = {5},
 number = {3},
 issn = {0018-8646},
 journal = {IBM Journal of Research and Development},
 doi = {10.1147/rd.53.0183}
}


@inproceedings{LBZ21,
 author = {Liu, Ji and Bello, Luciano and Zhou, Huiyang},
 title = {Relaxed Peephole Optimization: A Novel Compiler Optimization for Quantum Circuits},
 pages = {301--314},
 publisher = {{IEEE Press}},
 isbn = {978-1-7281-8613-9},
 booktitle = {Proceedings of the 2021 IEEE/ACM International Symposium on Code Generation and Optimization},
 year = {2021},
 address = {[S.l.]},
 doi = {10.1109/CGO51591.2021.9370310},
 file = {lbz21 Relaxed{\_}Peephole{\_}Optimization:Attachments/lbz21 Relaxed{\_}Peephole{\_}Optimization.pdf:application/pdf}
}


@article{LoCh19,
 author = {Low, Guang Hao and Chuang, Isaac L.},
 year = {2019},
 title = {Hamiltonian Simulation by Qubitization},
 pages = {163},
 volume = {3},
 journal = {Quantum},
 doi = {10.22331/q-2019-07-12-163}
}


@article{LPM*24,
 author = {Li, Zikun and Peng, Jinjun and Mei, Yixuan and Lin, Sina and Wu, Yi and Padon, Oded and Jia, Zhihao},
 year = {2024},
 title = {Quarl: A Learning-Based Quantum Circuit Optimizer},
 pages = {555--582},
 volume = {8},
 number = {OOPSLA1},
 journal = {Proceedings of the ACM on Programming Languages},
 doi = {10.1145/3649831}
}


@book{LuDe86,
 author = {Lutz, Christopher and Derby, Howard},
 year = {1986},
 title = {Janus: a time-reversible language},
 url = {https://tetsuo.jp/ref/janus.pdf}
}


@article{McKe65,
 author = {McKeeman, W. M.},
 year = {1965},
 title = {Peephole optimization},
 pages = {443--444},
 volume = {8},
 number = {7},
 issn = {0001-0782},
 journal = {Communications of the ACM},
 doi = {10.1145/364995.365000},
 file = {McKe65 - Peephole Optimization:Attachments/McKe65 - Peephole Optimization.pdf:application/pdf}
}


@article{MHH19,
 abstract = {The ability to prepare sizeable multi-qubit entangled states with full qubit control is a critical milestone for physical platforms upon which quantum computers are built. We investigate the extent to which entanglement is found within a prepared graph state on the 20-qubit superconducting quantum computer IBM Q Poughkeepsie. We prepared a graph state along a path consisting of all twenty qubits within the device and performed full quantum state tomography on all groups of four connected qubits along this path. We determined that each pair of connected qubits was inseparable and hence the prepared state was entangled. Additionally, a genuine multipartite entanglement witness was measured on all qubit subpaths of the graph state and we found genuine multipartite entanglement on chains of up to three qubits. These results represent a demonstration of entanglement in one of the largest solid-state qubit arrays to date and indicate the positive direction of progress towards the goal of implementing complex quantum algorithms relying on such effects.},
 author = {Mooney, Gary J. and Hill, Charles D. and Hollenberg, Lloyd C. L.},
 year = {2019},
 title = {Entanglement in a 20-Qubit Superconducting Quantum Computer},
 pages = {13465},
 volume = {9},
 number = {1},
 journal = {Scientific reports},
 doi = {10.1038/s41598-019-49805-7}
}


@article{MoOs,
 abstract = {In this paper we introduce the study of quantum boolean functions, which are unitary operators f whose square is the identity: f{\^{}}2 = I. We describe several generalisations of well-known results in the theory of boolean functions, including quantum property testing; a quantum version of the Goldreich-Levin algorithm for finding the large Fourier coefficients of boolean functions; and two quantum versions of a theorem of Friedgut, Kalai and Naor on the Fourier spectra of boolean functions. In order to obtain one of these generalisations, we prove a quantum extension of the hypercontractive inequality of Bonami, Gross and Beckner.},
 author = {Montanaro, Ashley and Osborne, Tobias J.},
 title = {Quantum boolean functions},
 url = {http://arxiv.org/pdf/0810.2435},
 journal = {Chicago Journal of Theoretical Computer Science vol}
}


@article{MVZJ18,
 abstract = {The aim of this paper is to elucidate the implications of quantum computing in present cryptography and to introduce the reader to basic post-quantum algorithms. In particular the reader can delve into the following subjects: present cryptographic schemes (symmetric and asymmetric), differences between quantum and classical computing, challenges in quantum computing, quantum algorithms (Shor's and Grover's), public key encryption schemes affected, symmetric schemes affected, the impact on hash functions, and post quantum cryptography. Specifically, the section of Post-Quantum Cryptography deals with different quantum key distribution methods and mathematicalbased solutions, such as the BB84 protocol, lattice-based cryptography, multivariate-based cryptography, hash-based signatures and code-based cryptography.

10 pages, 1 figure, 3 tables, journal article - IJACSA},
 author = {Mavroeidis, Vasileios and Vishi, Kamer and Zych, Mateusz D. and J{\o}sang, Audun},
 year = {2018},
 title = {The Impact of Quantum Computing on Present Cryptography},
 doi = {10.48550/arXiv.1804.00200}
}


@article{Niel06,
 author = {Nielsen, Michael A.},
 year = {2006},
 title = {Cluster-state quantum computation},
 pages = {147--161},
 volume = {57},
 number = {1},
 issn = {00344877},
 journal = {Reports on Mathematical Physics},
 doi = {10.1016/S0034-4877(06)80014-5}
}


@article{Oliv07,
 author = {de {Oliveira Guimar{\~a}es}, Jos{\'e}},
 year = {2007},
 title = {Learning compiler construction by examples},
 pages = {70--74},
 volume = {39},
 number = {4},
 issn = {0097-8418},
 journal = {ACM SIGCSE Bulletin},
 doi = {10.1145/1345375.1345418}
}


@article{PaFi11,
 abstract = {Despite the power of Parser Expression Grammars (PEGs) and GLR, parsing is not a solved problem. Adding nondeterminism (parser speculation) to traditional LL and LR parsers can lead to unexpected parse-time behavior and introduces practical issues with error handling, single-step debugging, and side-effecting embedded grammar actions. This paper introduces the LL(*) parsing strategy and an associated grammar analysis algorithm that constructs LL(*) parsing decisions from ANTLR grammars. At parse-time, decisions gracefully throttle up from conventional fixed k{\textgreater}=1 lookahead to arbitrary lookahead and, finally, fail over to backtracking depending on the complexity of the parsing decision and the input symbols. LL(*) parsing strength reaches into the context-sensitive languages, in some cases beyond what GLR and PEGs can express. By statically removing as much speculation as possible, LL(*) provides the expressivity of PEGs while retaining LL's good error handling and unrestricted grammar actions. Widespread use of ANTLR (over 70,000 downloads/year) shows that it is effective for a wide variety of applications.},
 author = {Parr, Terence and Fisher, Kathleen},
 year = {2011},
 title = {LL(*): the foundation of the ANTLR parser generator},
 pages = {425--436},
 volume = {46},
 number = {6},
 issn = {0362-1340},
 journal = {ACM SIGPLAN Notices},
 doi = {10.1145/1993316.1993548}
}


@article{PaQu95,
 abstract = {Despite the parsing power of LR/LALR algorithms, e.g. YACC, programmers often choose to write recursive-descent parsers by hand to obtain increased flexibility, better error handling, and ease of debugging. We introduce ANTLR, a public-domain parser generator that combines the flexibility of hand-coded parsing with the convenience of a parser generator, which is a component of PCCTS. ANTLR has many features that make it easier to use than other language tools. Most important, ANTLR provides predicates which let the programmer systematically direct the parse via arbitrary expressions using semantic and syntactic context; in practice, the use of predicates eliminates the need to hand-tweak the ANTLR output, even for difficult parsing problems. ANTLR also integrates the description of lexical and syntactic analysis, accepts LL(k) grammars for k {\textgreater} 1 with extended BNF notation, and can automatically generate abstract syntax trees.



ANTLR is widely used, with over 1000 registered industrial and academic users in 37 countries. It has been ported to many popular systems such as the PC, Macintosh, and a variety of UNIX platforms; a commercial C++ front-end has been developed as a result of one of our industrial collaborations.},
 author = {Parr, T. J. and Quong, R. W.},
 year = {1995},
 title = {ANTLR: A predicated-- LL ( k ) parser generator},
 pages = {789--810},
 volume = {25},
 number = {7},
 issn = {0038-0644},
 journal = {Software: Practice and Experience},
 doi = {10.1002/spe.4380250705}
}


@article{Pres18,
 author = {Preskill, John},
 year = {2018},
 title = {Quantum Computing in the NISQ era and beyond},
 pages = {79},
 volume = {2},
 journal = {Quantum},
 doi = {10.22331/q-2018-08-06-79}
}


@article{PSM*06,
 author = {Prasad, Aditya K. and Shende, Vivek V. and Markov, Igor L. and Hayes, John P. and Patel, Ketan N.},
 year = {2006},
 title = {Data structures and algorithms for simplifying reversible circuits},
 pages = {277--293},
 volume = {2},
 number = {4},
 issn = {1550-4832},
 journal = {ACM Journal on Emerging Technologies in Computing Systems},
 doi = {10.1145/1216396.1216399}
}


@article{RDB*22,
 author = {Rietsche, Roman and Dremel, Christian and Bosch, Samuel and Steinacker, L{\'e}a and Meckel, Miriam and Leimeister, Jan-Marco},
 year = {2022},
 title = {Quantum computing},
 pages = {2525--2536},
 volume = {32},
 number = {4},
 issn = {1019-6781},
 journal = {Electronic Markets},
 doi = {10.1007/s12525-022-00570-y}
}


@misc{RLB*24,
 abstract = {A key challenge in realizing fault-tolerant quantum computers is circuit optimization. Focusing on the most expensive gates in fault-tolerant quantum computation (namely, the T gates), we address the problem of T-count optimization, i.e., minimizing the number of T gates that are needed to implement a given circuit. To achieve this, we develop AlphaTensor-Quantum, a method based on deep reinforcement learning that exploits the relationship between optimizing T-count and tensor decomposition. Unlike existing methods for T-count optimization, AlphaTensor-Quantum can incorporate domain-specific knowledge about quantum computation and leverage gadgets, which significantly reduces the T-count of the optimized circuits. AlphaTensor-Quantum outperforms the existing methods for T-count optimization on a set of arithmetic benchmarks (even when compared without making use of gadgets). Remarkably, it discovers an efficient algorithm akin to Karatsuba's method for multiplication in finite fields. AlphaTensor-Quantum also finds the best human-designed solutions for relevant arithmetic computations used in Shor's algorithm and for quantum chemistry simulation, thus demonstrating it can save hundreds of hours of research by optimizing relevant quantum circuits in a fully automated way.},
 author = {Ruiz, Francisco J. R. and Laakkonen, Tuomas and Bausch, Johannes and Balog, Matej and Barekatain, Mohammadamin and Heras, Francisco J. H. and Novikov, Alexander and Fitzpatrick, Nathan and Romera-Paredes, Bernardino and {van de Wetering}, John and Fawzi, Alhussein and Meichanetzidis, Konstantinos and Kohli, Pushmeet},
 date = {22.02.2024},
 title = {Quantum Circuit Optimization with AlphaTensor},
 url = {http://arxiv.org/pdf/2402.14396v2}
}


@article{RSA78,
 author = {Rivest, R. L. and Shamir, A. and Adleman, L.},
 year = {1978},
 title = {A method for obtaining digital signatures and public-key cryptosystems},
 pages = {120--126},
 volume = {21},
 number = {2},
 issn = {0001-0782},
 journal = {Communications of the ACM},
 doi = {10.1145/359340.359342}
}


@inproceedings{Sark00,
 author = {Sarkar, Vivek},
 title = {Optimized unrolling of nested loops},
 pages = {153--166},
 publisher = {ACM},
 isbn = {1581132700},
 editor = {Reynders, John and Veidenbaum, Alex},
 booktitle = {Proceedings of the 14th international conference on Supercomputing},
 year = {2000},
 address = {New York, NY, USA},
 doi = {10.1145/335231.335246}
}


@article{Shor97,
 author = {Shor, Peter W.},
 year = {1997},
 title = {Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer},
 pages = {1484--1509},
 volume = {26},
 number = {5},
 issn = {0097-5397},
 journal = {SIAM Journal on Computing},
 doi = {10.1137/S0097539795293172}
}


@inproceedings{SWW*88,
 author = {Seshadri, V. and Weber, S. and Wortman, D. B. and Yu, C. P. and Small, I.},
 title = {Semantic analysis in a concurrent compiler},
 pages = {233--240},
 publisher = {ACM},
 isbn = {0897912691},
 editor = {Wexelblat, R. L.},
 booktitle = {Proceedings of the ACM SIGPLAN 1988 conference on Programming language design and implementation},
 year = {1988},
 address = {New York, NY, USA},
 doi = {10.1145/53990.54013}
}


@incollection{TAG12,
 author = {Thomsen, Michael Kirkedal and Axelsen, Holger Bock and Gl{\"u}ck, Robert},
 title = {A Reversible Processor Architecture and Its Reversible Logic Design},
 pages = {30--42},
 volume = {7165},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-642-29516-4},
 series = {Lecture Notes in Computer Science},
 editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and {Pandu Rangan}, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and de Vos, Alexis and Wille, Robert},
 booktitle = {Reversible Computation},
 year = {2012},
 address = {Berlin, Heidelberg},
 doi = {10.1007/978-3-642-29517-1{\textunderscore }3}
}


@misc{Thomtbd,
 author = {{Thomas Noll, Christina Gehnen, Roy Hermanns}},
 date = {tbd},
 title = {Quantum Computing: From Weakest Preconditions to Voltage Pulses},
 keywords = {Pre-release},
 institution = {{Software Modelling and Verification Group, RWTH Aachen University, Germany}},
 file = {Quantum Computing (Noll):Attachments/Quantum Computing (Noll).pdf:application/pdf}
}


@misc{van20,
 abstract = {The ZX-calculus is a graphical language for reasoning about quantum computation that has recently seen an increased usage in a variety of areas such as quantum circuit optimisation, surface codes and lattice surgery, measurement-based quantum computation, and quantum foundations. The first half of this review gives a gentle introduction to the ZX-calculus suitable for those familiar with the basics of quantum computing. The aim here is to make the reader comfortable enough with the ZX-calculus that they could use it in their daily work for small computations on quantum circuits and states. The latter sections give a condensed overview of the literature on the ZX-calculus. We discuss Clifford computation and graphically prove the Gottesman-Knill theorem, we discuss a recently introduced extension of the ZX-calculus that allows for convenient reasoning about Toffoli gates, and we discuss the recent completeness theorems for the ZX-calculus that show that, in principle, all reasoning about quantum computation can be done using ZX-diagrams. Additionally, we discuss the categorical and algebraic origins of the ZX-calculus and we discuss several extensions of the language which can represent mixed states, measurement, classical control and higher-dimensional qudits.},
 author = {{van de Wetering}, John},
 date = {27.12.2020},
 title = {ZX-calculus for the working quantum computer scientist},
 url = {http://arxiv.org/pdf/2012.13966v1}
}


@book{VSSD07,
 author = {{V. Aho}, Alfred and {S. Lam}, Monica and Sethi, Ravi and {D. Ullmann}, Jeffrey},
 year = {2007},
 title = {Compilers: Principles, techniques, {\&} tools},
 address = {Boston},
 edition = {2nd ed.},
 publisher = {{Pearson/Addison Wesley}},
 isbn = {0-321-48681-1}
}


@incollection{Wait74,
 author = {Waite, W. M.},
 title = {Semantic Analysis},
 pages = {157--169},
 volume = {21},
 publisher = {{Springer Berlin Heidelberg}},
 isbn = {978-3-540-06958-4},
 series = {Lecture Notes in Computer Science},
 editor = {Bauer, F. L. and de Remer, F. L. and Griffiths, M. and Hill, U. and Horning, J. J. and Koster, C. H. A. and McKeeman, W. M. and Poole, P. C. and Waite, W. M. and Eickel, J.},
 booktitle = {Compiler Construction},
 year = {1974},
 address = {Berlin, Heidelberg},
 doi = {10.1007/978-3-662-21549-4{\textunderscore }8}
}


@article{WeZa91,
 author = {Wegman, Mark N. and Zadeck, F. Kenneth},
 year = {1991},
 title = {Constant propagation with conditional branches},
 pages = {181--210},
 volume = {13},
 number = {2},
 issn = {0164-0925},
 journal = {ACM Transactions on Programming Languages and Systems},
 doi = {10.1145/103135.103136}
}


@article{Wine13,
 author = {Wineland, David J.},
 year = {2013},
 title = {Nobel Lecture: Superposition, entanglement, and raising Schr{\"o}dinger's cat},
 pages = {1103--1114},
 volume = {85},
 number = {3},
 issn = {0034-6861},
 journal = {Reviews of Modern Physics},
 doi = {10.1103/RevModPhys.85.1103}
}


@article{Wino78,
 author = {Winograd, S.},
 year = {1978},
 title = {On computing the discrete Fourier transform},
 pages = {175--199},
 volume = {32},
 number = {141},
 issn = {0025-5718},
 journal = {Mathematics of Computation},
 doi = {10.1090/S0025-5718-1978-0468306-4}
}


@article{WoZu82,
 author = {Wootters, W. K. and Zurek, W. H.},
 year = {1982},
 title = {A single quantum cannot be cloned},
 pages = {802--803},
 volume = {299},
 number = {5886},
 journal = {Nature},
 doi = {10.1038/299802a0}
}


@article{WPF*01,
 abstract = {A quantum Fourier transform (QFT) has been implemented on a three qubit nuclear magnetic resonance (NMR) quantum computer to extract the periodicity of an input state. Implementation of a QFT provides a first step towards the realization of Shor's factoring and other quantum algorithms. The experimental implementation of the QFT on a periodic state is presented along with a quantitative measure of its efficiency measured through state tomography. Experimentally realizing the QFT is a clear demonstration of the ability of NMR to control quantum systems.},
 author = {Weinstein, Y. S. and Pravia, M. A. and Fortunato, E. M. and Lloyd, S. and Cory, D. G.},
 year = {2001},
 title = {Implementation of the quantum Fourier transform},
 pages = {1889--1891},
 volume = {86},
 number = {9},
 issn = {0031-9007},
 journal = {Physical review letters},
 doi = {10.1103/PhysRevLett.86.1889}
}


@article{Ying11,
 author = {Ying, Mingsheng},
 year = {2011},
 title = {Floyd--hoare logic for quantum programs},
 pages = {1--49},
 volume = {33},
 number = {6},
 issn = {0164-0925},
 journal = {ACM Transactions on Programming Languages and Systems},
 doi = {10.1145/2049706.2049708},
 file = {ying11 floyd--hoare logic:Attachments/ying11 floyd--hoare logic.pdf:application/pdf}
}


@article{YuCa22,
 author = {Yuan, Charles and Carbin, Michael},
 year = {2022},
 title = {Tower: data structures in Quantum superposition},
 pages = {259--288},
 volume = {6},
 number = {OOPSLA2},
 journal = {Proceedings of the ACM on Programming Languages},
 doi = {10.1145/3563297}
}


@article{YVC24,
 author = {Yuan, Charles and Villanyi, Agnes and Carbin, Michael},
 year = {2024},
 title = {Quantum Control Machine: The Limits of Control Flow in Quantum Programming},
 pages = {1--28},
 volume = {8},
 number = {OOPSLA1},
 journal = {Proceedings of the ACM on Programming Languages},
 doi = {10.1145/3649811}
}


@misc{YVC24b,
 abstract = {OOPSLA 2024 Artifact: Quantum Control Machine

This artifact is being submitted to support the OOPSLA'24 paper {\textquotedbl}Quantum Control Machine: The Limits of Control Flow in Quantum Programming{\textquotedbl} by Charles Yuan, Agnes Villanyi, and Michael Carbin. The artifact contains:

README.md, this document

artifact.tgz, a Docker image containing source code, pre-built binaries, and tests

A~Dockerfile~that generates the above image from scratch

The directory~qcm-artifact, a copy of the contents of the Docker image, containing the source code of the simulator (src/) and the tests (test/)

The contents of this artifact are also available on~GitHub.

Kick-the-Tires: Getting Started with the Artifact

First, import~artifact.tgz~into Docker. In our testing, we used Docker Engine 24.0.6 on macOS Sonoma. The image may be loaded using the following commands:

{\$} docker load {\textless} artifact.tgz

Loaded image: qcm-artifact:latest

{\$} docker run -it --rm qcm-artifact bash

opam@502e0da78017:{\~{}}/qcm-artifact{\$}

The artifact is in the~qcm-artifact/~directory inside the user home directory. To quickly check that the artifact is functional, execute the following command and check that the output displays~state is synchronized:

{\$} cd {\~{}}/qcm-artifact/

{\$} ./qcm -r {\textquotedbl}x=3,y=0{\textquotedbl} -t 5 test/addition.qcm

(1.000000 + 0.000000i) |pc:7,br:1,x:3,y:3{\textgreater}

state is synchronized

Functionality: Validating the Paper's Claims

This artifact supports the following claim from Section 6 of the paper:

We have implemented a simulator for the quantum control machine, which accepts a program, input, and runtime~t, and outputs the machine state after~t~steps. Implementations of all case study examples as executable programs are also packaged with the simulator.

The easiest way to validate the claim is to do the following in the~qcm-artifact/~directory. First, ensure the simulator~./qcm~is present. If it is not, rebuild it from source by invoking~make~(for more instructions, see {\textquotedbl}Detailed Build Instructions{\textquotedbl} below).

Second, execute the simulator on all provided test programs by invoking~make check. This operation should take about one second to complete.

Finally, check that the output of~make check~is identical to the contents of the file~expected{\_}output. Specifically, the message~state is synchronized~should appear for all programs except~test/exponentiation-nosync.qcm, which should output~state is not synchronized.

Each example program for the quantum control machine presented in the paper corresponds to a program in the~test/~directory:

Figure 2 in the paper corresponds to~test/addition.qcm.

Figure 6 in the paper corresponds to~test/exponentiation-nosync.qcm.

Figure 7 in the paper corresponds to~test/exponentiation.qcm.

Figure 8 in the paper corresponds to~test/hadamard.qcm.

Figure 10 in the paper corresponds to~test/majorana.qcm.

As a technical note, the paper presents each program using named labels (e.g.~l1:). By contrast, the formal language specification in Table 1 of the paper, as well as this artifact, use explicit line offsets (e.g.~{\$}+3) rather than labels. For each program, we have provided the version with named labels as seen in the paper in a file suffixed~-labels, e.g.~test/addition-labels.qcm. We have also provided a simple script~label2offset.py~that can be used to convert named labels to explicit line offsets. One may convert~test/addition-labels.qcm~to~test/addition.qcm~by running:

./label2offset.py {\textless} test/addition-labels.qcm {\textgreater} test/addition.qcm

Reusability: Writing Programs

The simulator included in the artifact makes it possible to write new programs and extend the functionality of the simulator. The file~src/README.md~describes the organization of the simulator sources, should you wish to modify the code.

To execute a program, supply it as an argument to the simulator, for example:

{\$} ./qcm -r {\textquotedbl}x=3,y=0{\textquotedbl} -t 5 test/addition.qcm

(1.000000 + 0.000000i) |pc:7,br:1,x:3,y:3{\textgreater}

state is synchronized

{\$} ./qcm -r {\textquotedbl}res=0,r1=0,x=2,y=1{\textquotedbl} -r {\textquotedbl}res=0,r1=0,x=2,y=2{\textquotedbl} -t 10 test/exponentiation-nosync.qcm

(0.707107 + 0.000000i) |pc:5,br:1,res:4,r1:1,y:2,x:2{\textgreater} + (0.707107 + 0.000000i) |pc:8,br:1,res:2,r1:0,y:1,x:2{\textgreater}

state is not synchronized

The~-t~flag specifies the number of steps to execute. The~-r~flag specifies the initial register state, a comma-separated list of variable names and values separated by~=. Specifying multiple instances of~-r~initializes the register state to the uniform superposition of the specified states.

The output of the simulator is the final state of the machine, which is a complex vector of amplitudes and register states. The simulator also outputs whether the state is synchronized or not, i.e. whether the values of~pc~and~br~are equal across all states in the final superposition.

To see examples of programs and invocations, see the~test/~directory and the~Makefile. To see the full list of options, run:

./qcm --help

Detailed Build Instructions

In the provided image, simply run~make~within~qcm-artifact~to build the simulator from source.

To build the simulator outside of the image, first install OCaml version 5.0.0 with~dune~and the libraries~core,~menhir, and~ppx{\_}deriving. The recommended way to install OCaml and the dependent libraries is via~OPAM. Then, to build the simulator~./qcm, simply run~make.},
 author = {Yuan, Charles and Villanyi, Agnes and Carbin, Michael},
 year = {2024},
 title = {Quantum Control Machine: The Limits of Control Flow in Quantum Programming},
 publisher = {Zenodo},
 doi = {10.5281/ZENODO.10452601}
}


@misc{YYF12,
 abstract = {A remarkable difference between quantum and classical programs is that the control flow of the former can be either classical or quantum. One of the key issues in the theory of quantum programming languages is defining and understanding quantum control flow. A functional language with quantum control flow was defined by Altenkirch and Grattage [\textit{Proc. LICS'05}, pp. 249-258]. This paper extends their work, and we introduce a general quantum control structure by defining three new quantum program constructs, namely quantum guarded command, quantum choice and quantum recursion. We clarify the relation between quantum choices and probabilistic choices. An interesting difference between quantum recursions with classical control flows and with quantum control flows is revealed.},
 author = {Ying, Mingsheng and Yu, Nengkun and Feng, Yuan},
 date = {19.09.2012},
 title = {Defining Quantum Control Flow},
 url = {http://arxiv.org/pdf/1209.4379v1}
}


@article{ZRK*11,
 abstract = {Although quantum computers promise significant advantages, the complexity of quantum algorithms remains a major technological obstacle. We have developed and demonstrated an architecture-independent technique that simplifies adding control qubits to arbitrary quantum operations-a requirement in many quantum algorithms, simulations and metrology. The technique, which is independent of how the operation is done, does not require knowledge of what the operation is, and largely separates the problems of how to implement a quantum operation in the laboratory and how to add a control. Here, we demonstrate an entanglement-based version in a photonic system, realizing a range of different two-qubit gates with high fidelity.},
 author = {Zhou, Xiao-Qi and Ralph, Timothy C. and Kalasuwan, Pruet and Zhang, Mian and Peruzzo, Alberto and Lanyon, Benjamin P. and O'Brien, Jeremy L.},
 year = {2011},
 title = {Adding control to arbitrary unknown quantum operations},
 url = {https://www.nature.com/articles/ncomms1392},
 pages = {413},
 volume = {2},
 number = {1},
 issn = {2041-1723},
 journal = {Nature Communications},
 doi = {10.1038/ncomms1392}
}


