\section{Summary}
For this thesis, we designed a quantum programming language with control flow primitives in superposition and implemented a corresponding compiler. This compiler cover all the typical step, including the lexical, syntactic, and semantic analysis of the code as well as the code generation and optimization. The result is the translated OpenQASM.

In the beginning, the discussed some related work and background and the topic of quantum control flow and quantum computing in general; we presented the concept of quantum control flow and its limitations. Next, we introduced the Quantum Control Machine, an instruction set architecture focused on quantum control flow with instructions similar to classical assembly language. Additionally, we discussed other low and high-level quantum programming languages, such as the Open Quantum Assembly (OpenQASM) language. Lastly, we gave a short introduction into the compilation of programs, including the different steps and some tools to build compilers or compiler steps.

On the basis of the background knowledge, we discussed the concept for our quantum language with quantum control flow primitives. First, we gave a language overview with the different data types, operations, control flow statements, and other language concepts. Next, we defined a formal grammar for our language. Based on the grammar, we defined formal translation functions which translate our custom programming language to OpenQASM. Lastly, we introduced different optimization rules that we intend to apply in the code optimization stage of the compiler. Furthermore, we defined a circuit graph, which is a graphical representation of a quantum circuit or program, and discussed an algorithm to apply the optimization rules to the graph.

Next, the concept for the programming language and its translation was used to implement a compiler for the language. First, we discussed functionalities of the compiler, such as the command line interface, as well as general concepts. Next, we explained how the grammar is used to implement the lexical and syntactic analysis with the ANTLR tool. Then, we discussed the semantic analysis, including declaration analysis and type checked as well as general error handling in the compiler. This is followed by a discussion of the code generation stage and an example translation. Lastly, we explained the optimization implementation based on the circuit graph and discussed some additional algorithms for constructing and translating the graph. 

Finally, in the evaluation we analyzed two aspects of our compiler, the optimization performed by the compiler and the execution times of the different compilation stages. The quantum ripple-carry adder was implemented in Luie and used with different input values for the evaluation. In the case of classical input, the optimization stage could reduce the circuit to only the necessary gate to initialize the result of the addition. While the optimization was not as effective for inputs in superposition, depending on the size of the registers and how many qubit were affected by the values in superposition, the circuit could be reduced significantly. Next, the performance of the compilation was evaluated with the same example algorithm with differing register sizes. While semantic analysis stage did not take longer with increasing register sizes, the time to generate the target code increased linearly. Similarly, the optimization stage showed a quadratic increase in execution time when increasing the register size.    