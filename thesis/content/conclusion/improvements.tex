\section{Improvements and Future Work}
In our project we designed a quantum programming language and implemented a corresponding compiler with all basic elements, lexical, syntactic, and semantic analysis, as well as code generation and optimization. However, the evaluation revealed aspects that can be improved. Furthermore, there is also room for further improvements to aspects of the language and compiler that were not considered in the evaluation.

The first aspect that was evaluated was the optimizations performed on the generated code. Our current implementation focuses on high-level optimizations to the quantum circuit. Therefore, the compiler can work in tandem with the Qiskit kit but, in turn, is less useful as a standalone tool and is best utilized as part of a toolchain. A possible improvement is the addition of more hardware-focused features such as transpilation and compilation to concrete devices. Furthermore, with a more hardware-specific focus, the optimization rules can be extended with more hardware-specific rules.
Additionally, the set of optimizations can be expanded to include more high-level ones. For example, when the value of a quantum state is discarded, it is implicitly measured. In our language, this happens each time a qubit or register is no longer in scope. 
Therefore, the compiler could automatically reuse qubits or registers that are out of scope or no longer used, as suggested in Sec.~\ref{sec:concept_controlFlow}, by measuring and resetting them; in turn, the qubit count of the circuit is reduced. However, this does not automatically perform uncomputations, and they need to be performed manually by the user, as is the case currently.

Secondly, besides the optimization rules, we evaluated the performance of the different compilation stages. While the semantic analysis and code generation stages showed, at worst, linear time complexity, the optimization stage grew approximately quadratically with the input size. Therefore, the optimization stage is inefficient for a large number of gates or qubits. To improve the performance of the compiler, the first focus should be to optimize the optimization stage. One suggestion to improve the performance would be to parallelize the iteration over the qubit wires, with each wire being scanned for optimizations by a separate thread. However, while this approach should reduce the execution time of the optimization significantly, the resulting algorithm would be more complex; new aspects such as race conditions need to be considered, and, in turn, the quantum circuit graph needs to be protected from being modified by multiple threads at the same time. This could be achieved by, \eg, a mutex. Additionally, currently each optimization rule is a static object. When the optimization process is running on multiple threads, the intermediate values of the rule may be overwritten. Therefore, either a new rule object needs to be created for each thread, increasing the used memory, or the rules need to recalculate the values, impacting the performance of the program.

Besides the evaluated aspects, there are also other parts that can be improved. Currently, a weak aspect of the language is the typecasting. All elements of an expression are of the same type, and, if they are not, they are cast implicitly to the target type. For example, when an identifier that is a constant double with a value of $9.9$ is used in an expression for the size of a register, by definition an integer expression, the value is cast to be an integer with a value of $9$. While the behavior is consistent, it differs from most other strongly typed languages where floating point values need to be explicitly cast to an integer type. In turn, the language could be expanded to include not only implicit but also explicit casting.

Furthermore, the range of predefined functions, provided by the language, is currently limited to only a handful of functions. These could be expanded by additional functions such as sine and cosine or even mathematical constants such as $\pi$ and Euler's number $e$. Moreover, the language could be extended to provide functionalities for users to define their own functions with macros or lambda functions. With such functionality, often-used and more complex expressions could be expressed as custom functions and reused.

Lastly, while our language can be used to express any quantum circuit or algorithm, most quantum languages offer functionalities that provide more control over the quantum circuit. One example is explicit measurements. Our language only provides implicit measurements, \ie, all qubits and registers are automatically measured at the end of the circuit, and their results are written to corresponding qubits. However, most quantum languages provide the user with the ability to declare classical bits and registers, explicitly measure qubits and quantum registers, and write the measurement results to the corresponding classical data type. With explicit measurements, the user has more control over when measurements take place and what qubits need to be measured. For example, many algorithms use auxiliary qubits that do not need to be measured. Furthermore, with explicit measurements, the user can measure and reuse qubits for other purposes and, in turn, reduce the overall qubit count. Lastly, with explicit measurement, the measurement results can be used to conditionally execute parts of a circuit; this is required for, \eg, quantum teleportation.