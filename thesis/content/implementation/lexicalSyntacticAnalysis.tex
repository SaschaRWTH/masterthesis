\section{Lexical and syntactic analysis}
\label{sec:implementation_syntaxAnalysis}
The lexical and syntactic analysis steps of the compiler are not implemented by hand but ANTLR4 is used to generate both the lexer and parser. In Sec.~\ref{sec:background_compilerTools}, a short introduction is given into the generation tool. The tool does not only generate the lexer and parser for the language but also some data structures, like the parse tree, and abstract classes that are used for the following compiler steps. In the following, we discuss the ANTLR grammar of Luie and give an overview of the different classes that are generated by ANTLR.

\subsection{Grammar}
\label{sec:implementation_grammar}
The entry point for the grammar is a parsing rule called \texttt{parse}. It states that the program consists of a main code block followed by the end of file lexer token \texttt{EOF}. The main code block starts with arbitrarily many gate declarations, or none at all, and is followed by any number of declarations and statements in any order, or none at all. Similarly, a ``normal'' code block also consists of any number of declarations and statement; however, it does not allow for gate declaration. The grammar for the entry point, main and general code block is depicted in Fig.~\ref{fig:implementation_grammarStructure}

\begin{figure}[htp]
    \centering
    \lstinputlisting[style=ANTLR]{../figures/code/grammar_structure.g4}
    \caption{The basic structure parsing rules of Luie.}
    \label{fig:implementation_grammarStructure}
\end{figure}

While syntactically it would be equal to say the main block consists of gate declarations and a code block, the code generation implementation requires the main code block to directly hold the declarations and statements. Internally, each code block object holds a list of declarations and statements which, in turn, can hold references to other codeblocks. However, a block itself cannot hold a reference to another block. Furthermore, the code generation is only called on the main code block which, then, recursively calls the code generation for each declaration and statement. Therefore, the main code block needs to contain the declarations and statements directly, otherwise the code generation will alway generate an empty program. 

There are three kinds of declaration rules in the grammar. The first is the declaration rule for qubits and registers. It start with the register keyword lexer token, followed by an optional expression in brackets giving the size. If no size is given, a qubit is created; otherwise, a register with the given size is created. The identifier for the qubit or register is the last part of the rule. 

\begin{figure}[htp]
    \centering
    \lstinputlisting[style=ANTLR]{../figures/code/grammar_declarations.g4}
    \caption{The parsing rules for declarations in Luie.}
    \label{fig:implementation_grammarDeclarations}
\end{figure}

Next, the constant declaration rule is used to declare constants that can be used at compile time, \eg for the size of registers or to given the number of loop iterations. Similar to register and qubit declarations rule, the rule start with a constant keyword token. Then, the identifier is given and separated from the type of the constant with a colon. Lastly the expression for the value of the constant is given after an equality sign.

The final declaration rule is used for composite gate. Again, it starts with a corresponding keyword and is followed by the identifier of the gate. Next, the optional\todo{Should gate parameters be optional?} gate parameter rule is given in parenthesis. The gate parameter rule matches any number of identifiers, separated by commas, requiring at least one identifier. Lastly, the gate declaration rule ends with a code block rule. 

All declaration rules are given in Fig.\ref{fig:implementation_grammarDeclarations}. Note that the depicted grammar is semantically equal to the grammar used in the implementation; however, some of the formatting and naming was adjusted for the thesis.
\unsure{should this be specifically stated?}

The grammar contains four different type of statements. The first is the gate applications statements, followed by two the control flow statement and, lastly, the skip statement. The gate application statement start with the gate rule. A gate can either be a constant, or predefined, gate such as the Hadamard or $X$ gate, a parameterized gate, such as $P(\lambda)$, or a composite gate given by its identifier. In the case of the parameterized gate, the parameter is given by an expression. Following the gate rule, the register rules specify to which qubits or registers the gate is applied. Here, at least one argument is required but there can be arbitrarily many arguments, each separated by a comma. A register or qubit can either be given by the corresponding identifier or as a register access. In this case, the index to be accessed is given by an expression. The grammar rules related to the gate application statement are also depicted in Fig.~\ref{fig:implementation_grammarGateStatements}. 

\begin{figure}[htp]
    \centering
    \lstinputlisting[style=ANTLR]{../figures/code/grammar_gateStatements.g4}
    \caption{The parsing rules for gate statements in Luie.}
    \label{fig:implementation_grammarGateStatements}
\end{figure}

If statement ...

Loop statement ...

\begin{figure}[htp]
    \centering
    \lstinputlisting[style=ANTLR]{../figures/code/grammar_controlflowStatements.g4}
    \caption{The parsing rules for the control flow statements in Luie.}
    \label{fig:implementation_controlFlowStatements}
\end{figure}

\subsection{Data structures and classes}
\label{sec:implementation_syntax_dataStructuresClasses}
\begin{itemize}
    \item Listeners eg
\end{itemize}
