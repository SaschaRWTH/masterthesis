\section{Lexical and Syntactic Analysis}
\label{sec:implementation_syntaxAnalysis}
The lexical and syntactic analysis steps of the compiler are not implemented by hand, but ANTLR4 is used to generate both the lexer and parser. In Sec.~\ref{sec:background_compilerTools}, a short introduction is given into the generation tool. The tool does not only generate the lexer and parser for the language but also some data structures, like the parse tree, and abstract classes that are used for the following compiler steps. In the following, we discuss the ANTLR grammar of Luie and give an overview of the different classes that are generated by ANTLR.

\subsection{Grammar}
\label{sec:implementation_grammar}
The entry point for the grammar is a parsing rule called \texttt{parse}. It states that the program consists of a main code block followed by the end-of-file lexer token \texttt{EOF}. The main code block starts with arbitrarily many gate declarations, or none at all, and is followed by any number of declarations and statements in any order, or none at all. Similarly, a ``normal'' code block also consists of any number of declarations and statements; however, it does not allow for gate declaration. The grammar for the entry point, main, and general code block is depicted in Fig.~\ref{fig:implementation_grammarStructure}.

\begin{figure}[htp]
    \centering
    \lstinputlisting[style=ANTLR]{../figures/code/implementation/grammar_structure.g4}
    \caption{The basic structure of parsing rules for Luie.}
    \label{fig:implementation_grammarStructure}
\end{figure}

While syntactically it would be equal to say the main block consists of gate declarations and a code block, the code generation implementation requires the main code block to directly hold the declarations and statements. Internally, each code block object holds a list of declarations and statements which, in turn, can hold references to other codeblocks. However, a block itself cannot hold a reference to another block. Furthermore, the code generation is only called on the main code block, which then recursively calls the code generation for each declaration and statement. Therefore, the main code block needs to contain the declarations and statements directly;otherwise, the code generation will always generate an empty program. 

There are three kinds of declaration rules in the grammar. The first is the declaration rule for qubits and registers. It starts with the register keyword lexer token, followed by an optional expression in brackets giving the size. If no size is given, a qubit is created; otherwise, a register with the given size is created. The identifier for the qubit or register is the last part of the rule.

\begin{figure}[htp]
    \centering
    \lstinputlisting[style=ANTLR]{../figures/code/implementation/grammar_declarations.g4}
    \caption{The parsing rules for declarations in Luie.}
    \label{fig:implementation_grammarDeclarations}
\end{figure}

Next, the constant declaration rule is used to declare constants that can be used at compile time, \eg, for the size of registers or to give the number of loop iterations. Similar to register and qubit declaration rules, the rule starts with a constant keyword token. Then, the identifier is given and separated from the type of the constant with a colon. Lastly, the expression for the value of the constant is given after an equality sign.

The final declaration rule is used for composite gates. Again, it starts with a corresponding keyword and is followed by the identifier of the gate. Next, the gate parameter rule is given in parentheses. The gate parameter rule matches any number of identifiers, separated by commas, requiring at least one identifier. Lastly, the gate declaration rule ends with a code block rule.

All declaration rules are given in Fig.~\ref{fig:implementation_grammarDeclarations}. Note that the depicted grammar is semantically equal to the grammar used in the implementation; however, some of the formatting and naming was adjusted for the thesis.

The grammar contains four different types of statements. The first is the gate application statement, followed by two control flow statements and, lastly, the skip statement. The gate application statement starts with the gate rule. A gate can either be a constant or predefined gate, such as the Hadamard or $X$ gates; a parameterized gate, such as $P(\lambda)$; or a composite gate given by its identifier. In the case of the parameterized gate, the parameter is given by an expression. Following the gate rule, the register rules specify to which qubits or registers the gate is applied. Here, at least one argument is required, but there can be arbitrarily many arguments, each separated by a comma. A register or qubit can either be given by the corresponding identifier or as a register access. In this case, the index to be accessed is given by an expression. The grammar rules related to the gate application statement are also depicted in Fig.~\ref{fig:implementation_grammarGateStatements}.

\begin{figure}[]
    \centering
    \lstinputlisting[style=ANTLR]{../figures/code/implementation/grammar_gateStatements.g4}
    \caption{The parsing rules for gate statements in Luie.}
    \label{fig:implementation_grammarGateStatements}
\end{figure}

Next, the first control flow statement is the if-statement. It starts with the \texttt{if} keyword, which is followed by the register rule. This register is the qubit that controls the execution of the body. After the control bit is specified, the \texttt{ifStat} rule gives the code block that is controlled by the control bit. This is followed by an optional else-block; it starts with the \texttt{else} keyword and the corresponding code block. Both the main and else code blocks are introduced by the \texttt{do} keyword. Lastly, the if-statement is ended with the \texttt{end} keyword.

\begin{figure}[b]
    \centering
    \lstinputlisting[style=ANTLR]{../figures/code/implementation/grammar_controlflowStatements.g4}
    \caption{The parsing rules for the control flow statements in Luie.}
    \label{fig:implementation_controlFlowStatements}
\end{figure}

The second and last control flow statement is the loop statement. Similar to other statements and declarations, it starts with the corresponding \texttt{for} keyword. Next, the identifier for the loop iterator is given, followed by the \texttt{in} keyword. Then, the range for the loop statement is specified. There are three different possibilities to give the range. Firstly, the simplest syntax for a range is the start and end indices separated by two dots. The other two options both start with the \texttt{range} keyword followed by arguments in parentheses. The first option only gives the length of the range as an expression, while the second specifies both the start and end indices as expressions. Lastly, the body of the loop is a code block surrounded by the \texttt{do} and \texttt{end} keywords.
The grammar rules for both control flow statements are depicted in Fig.~\ref{fig:implementation_controlFlowStatements}.

An expression mainly consists of three different grammar rules. The first rule is the expression rule itself. It matches the operands with the lowest precedence. In our case, these are both the addition and subtraction operations. The left-hand side of the addition and subtraction is also an expression. In contrast, the right-hand side specifies a term rule. Alternatively, the expression can also be neither an addition nor a subtraction but just a term.

Similar to the expression rule, the term represents two operations. In this case, they are the multiplication and division operations with neither the highest nor the lowest precedence. While the left-hand side of both operations matches the term rule again, the right-hand side specifies a factor. Again, the term can also be neither a multiplication nor a division but a factor instead.

\begin{figure}[htp]
    \centering
    \lstinputlisting[style=ANTLR]{../figures/code/implementation/grammar_expression.g4}
    \caption{The parsing rules for an expression in Luie.}
    \label{fig:implementation_expression}
\end{figure}

Lastly, the factor rule includes all operations with the highest precedence. The first option is an expression in parentheses. 
The second possibility is a negated factor. Finally, the factor can either be the result of a function, the value of an identifier, or an integer value itself. While the value of an identifier is just given by the identifier itself and the integer value is specified by giving the integer, the result of a function is given by the function rule. The function rule starts with the name of the function. An example of a function name is \texttt{sizeof} or \texttt{power}. The name of the function is followed by the function parameters in parentheses. The function parameters are either a list of identifiers or expressions separated by commas. Both require at least one identifier or expression but allow for arbitrarily many.
The additional case of a list of identifiers is added since registers are not allowed in expressions but are used in the \texttt{sizeof} function. However, this can lead to issues when, \eg, the \texttt{min} function is given a list of constants. These problems are addressed in the implementation for the creation of function objects where, in some cases, a list of identifier expressions is created from a list of identifiers.
All expression grammar rules as well as the function-related rules are given in Fig.~\ref{fig:implementation_expression}. Furthermore, all terminal symbols, such as the different functions and the regular expressions for identifiers and integers, are given in Sec.~\ref{appendix:grammar_terminals} of the appendix.

\subsection{Data Structures and Classes}
\label{sec:implementation_syntax_dataStructuresClasses}
Based on the grammar discussed in the previous section, the ANTLR tool generates different classes and files that can be used for the lexical and syntactic analysis of the source program. The tool generates token files as well as the necessary classes for the analyses; these classes inherit from abstract base classes such as \texttt{Lexer} or \texttt{Parser} that are contained in the ANTLR runtime package. Additionally, the tool can also generate optional classes that can be used for the semantic analysis of the program or for code generation; these classes are the \texttt{Listener} and \texttt{Visitor}.

After the lexical and syntactic analysis yields the parse tree of the source code, both the listener and visitor classes can be used to traverse the tree. They implement a list of virtual functions without any effect. Then, these can be overridden and extended by custom functionality. The visitor class has a generic type parameter \texttt{Result} and implements a visit function that returns \texttt{Result} for each grammar rule. For example, in the case of our grammar, as discussed in Sec.~\ref{sec:implementation_grammar}, the visitor class implements, among other things, a \texttt{VisitParse} and \texttt{VisitMainblock} function.
Additionally, for each grammar rule, there exists a context that provides information about the rule, such as its line and column in the source code. Furthermore, the context can be used to get information about the terminal in a rule. For example, in the case of the expression rule, the context can be used to learn which operation, either addition or subtraction, was given. The parse tree can be traversed by implementing the different visit functions and, in their implementation, having them call their child rules.

In contrast, the listener class does not have a generic type parameter, and, in turn, its functions do not return anything either. However, instead of implementing a visit function for each grammar rule, the listener implements both an enter and an exit function for each rule. Furthermore, the functions corresponding to the children in the parse tree are not explicitly, but the tree is traversed by a walker class, and the enter and exit functions are called in order of the traversal. Therefore, the \texttt{EnterParse} function is the first function that will be called, while \texttt{ExitParse} is the last. Similar to the visitor functions, both the enter and exit functions have the context of the corresponding grammar rule as an argument. Both our semantic analysis and code generation implementation create custom listener classes instead of visitors. We use listeners as they offer an implementation better suited for our use case and an overall simple implementation, as they only require passive listening functions. In contrast, the visitor needs to actively implement the tree traversal. Furthermore, visitors require a unified return type; while for most rules, this could be a translatable, this type would not fit the creation of expressions.