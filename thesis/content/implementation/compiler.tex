\section{Compiler}
% \begin{itemize}
%     \item Static compiler class
%     \begin{itemize}
%         \item General information
%     \end{itemize}
%     \item How are different parts called
%     \item How do they interact?
%     \item Discuss general concepts and classes used by compiler
%     \begin{itemize}
%         \item Compiler data
%         \item IO Handler
%     \end{itemize}
% \end{itemize}
The compiler consists of multiple classes and stages that work together to compile and optimize the given program. While most of the compiler can be divided into discrete stages, there are multiple overarching classes and commonly used structures that do not belong to a certain stage. In the following section, we discuss the implementation of general functionalities and introduce the commonly used structures.

When the compiler program is started, the main function calls the Command Line Interface class to parse the arguments to the compiler data class. The compiler data is used to enable and control the compilation process; it contains all required information such as the path to the input and output files. Furthermore, it specifies which optimizations are to be applied to the compiled program. Lastly, it indicates, whether the compilation process is to be executed verbosely. 

After the compiler data is parsed, the main function passes it to the compile function of the compiler class. This is a static class containing general compilation and printing functionalities as well as corresponding properties. We implement it as a static class so that all parts of the program can easily access its functions and properties. The first property of the compiler is the \texttt{Printer} function; its default value is the native console printing function of C\# but it can be set to any arbitrary function that takes a string as an input and does not return anything. While this property is not changed in a normal compilation process, it is used to check the console output of the compiler in the test cases. Secondly, the verbose property indicates whether the compiler prints not only the errors to the user but also the warnings and informational logs.

To interact with the printer property of the compiler, there are a variety of different printing and logging functions; in the end, all use a sing print function that uses the printer property to display a given message. While the printing functions, used for printing errors and warnings, call the print function directly, the logging functions have an additional check so that they only print, if the compiler is executed verbosely. Lastly, the logging functions also use compiler services of the runtime to allow for special injections. All of the logging functions have the optional member name and line number arguments that are annotated with special attribute. In turn, if the optional arguments are not set, the compiler injects the name of the caller for this function as well as the line number where it was called. This can be helpful when trying to debug issues with the compiler.  

The compile function handles the entire remaining compilation process. First, it retrieves the program code from the given input path. For the reading and saving of files, a separate \texttt{IOHandler} class exists that has some basic logic for reading and writing files. Then, the parse tree is created and passed to the semantic analysis of the compiler. Here all errors and warning are printed to the used. If any errors are thrown, the compilation is aborted. Next, the code is generated from the parse tree. If the compilation resulted in error, again, the compilation is arbored. After the code is generated, it is optimized based on the optimizations given in the compiler data. Lastly, the resulting program is written to the file specified by the output path.

\subsection{Command Line Interface}
As the interface between the programmer and the compiler itself, the command line interface (CLI) is an essential part of the compiler. 
Its purpose is to interact with the programmer and created the compiler data which specifies the behavior of the compiler. 
To achieve this, the CLI consists of two different parts. The first are the attributes that are used to annotate the compiler data class and the second part is the CLI Handler; it parses the input arguments and creates the compiler data from them. Additionally, it print the help text to the console if needed.

An attribute is a C\# class that can be used to annotate fields and properties of another class; together with reflection, it can be used to create a modular and easily extendable compiler data class with parameters and descriptions for each compiler data property. Reflection allows programs to get information on types of loaded assemblies. In our case, we are interested in the information on classes, more specifically information on properties of the compiler data class. We create custom attributes with a class that inherits from the \texttt{Attribute} class and contains the required information about the properties we need. With reflection, our program can get a list of all properties with specific attributes and use their information to create, \eg, the help text of the CLI. In turn, we have two custom attributes in our program. The first it the \texttt{CLIParameterAttribute} which specifies both the short and long name of an attribute corresponding to the compiler data property. For example, in the case of the input path property, the short name is a lower case ``i'' and the long name is ``input''. The second attribute is the \texttt{CLIDescriptionAttribute}; it contains a description for the property it is applied to. Then, this description can be display in the help text. In the case of the input path property, the description describes that the parameter describes the path to the input file. The code for the input path property example is depicted in Fig.~\ref{fig:implementation_inputPathAttribute}.

\begin{figure}[htp]
    \centering
    \begin{lstlisting}[language=csh]
[CLIParameter('i', "input")]
[CLIDescription("Path to the input file.")]
public string InputPath { get; set; } = string.Empty;
    \end{lstlisting}
    \caption{The input path property declaration with its parameter and description attribute.}
    \label{fig:implementation_inputPathAttribute}
\end{figure}

To parse the command line arguments and create the compiler data from it, the command line interface class is used; it consists of functions to parse the arguments and print the help text to the console. Since the syntax for the CLI argument input is very basic, the command line parsing itself is basic. The input string is split at each space and given to the function as a string array. First, the function retrieves the CLI parameter attributes for all compiler data properties. Then, it iterates over the string array and, for each array entry, checks whether the parameter attribute matches the string; for example, in the case of the input path property, the string would have to be either ``-i'' or ``--input''. If this is the case, the corresponding parsing function, depending on the matched argument, is called with the string array and a reference to current index. A reference to the index is used to allow for further changes to the index, depending on the number of possible arguments for a parameter. For example, the verbose parameter will always return true and not change the index while a path parameter will increment the index and return the next string of the array. If no attribute can be matched or an argument exception is thrown in the process, the compiler will notify the user of the invalid or missing argument and print the help text to clarify the compiler options.

The help text is created based on the attributes of the properties in the compiler data class. Firstly, the function retrieves both the parameter and description attributes. Since the compiler data class does not include the help parameter, as it is only used in the CLI context, the help text manually prints its information. Then, the parameters are iterated. For each parameter, a matching description is searched. If no description can be found, the text defaults to a message indicating that non is available. Lastly, both the parameter and corresponding description are printed to the console.

\subsection{Symbols}
One part that is used in most stages of the compilation process, mainly the semantic analysis and code generation, are the symbols; they are used to store all necessary information on data type, composite gates, and similar object in the language. The basis is an abstract symbol class that consists of an identifier and error context property. The identifier uniquely identifies a symbol in the scope it is used while the error context saves information about the symbol and its declaration environment to be used for possible error messages. In total there are eight different symbols that are derived from the class. In the following, we discuss these symbols and how they are used in the compiler. The hierarchy of the symbol classes is depicted in an UML diagram in Fig.~\ref{fig:implementation_uml_symbols}.

\begin{figure}[htp]
    \centering
    \includegraphics[width=.9\textwidth]{../figures/uml_symbols.pdf}
    \caption{UML diagram of the different symbols.}
    \label{fig:implementation_uml_symbols}
\end{figure}

There are three different symbol for quantum data types. The first kind is the register. Futhermore, it is the basis of all other quantum data type symbols. Besides the inherited properties, it consists of an expression that represents the size of the register. The expression specifying the size of the register may not be evaluable when its symbols is crease because the value of some identifiers may be known only at generation time.\todo{Introduce ``generation time'' as phrase with clear meaning}
For example, the body of a loop statement is unrolled at generation time and the values of the loop iterator depends on this iteration. In turn, the value of the iterator identifier may not be known when the register symbol is created. Therefore, instead of saving a constant value, the symbol specifies the expression for its size. Then, when the code is generated and all values are know, the expression can be evaluated.    

Next, the qubit symbol inherits from the register. While physically the qubit is the basic element and a register consist of qubits, in our case, it is useful to assume that a qubit is a special case of a register where the size is one so that the qubit can inherit the register symbol properties and functions. Furthermore, instead of differentiating between a qubit and register declaration, a register declaration is sufficient for this hierarchy, only requiring a differentiation when printing the code. In turn, all registers with size one are inherently optimized to be qubit in the target code. Besides setting the size to one, the qubit symbol has no additional attributes.

The last quantum data type symbol is the register access. This symbol is necessary because the access of a register is not implemented as an expression. Since a register access cannot be used in any expression and only in the context of a gate application or if statement, instead of implementing special quantum expressions, that can only be used in limited cases, we create another symbol. The register access symbol inherit from the qubit symbol as it can be used whenever a qubit symbol can be used. For example, in the case of a gate application statement, a list of qubits, to which the gate is applied, is saved. In turn, since each register access is a qubit, no additional list or differentiation is required for the gate application, only a virtual function to return the translated qubit code. The symbol also contains an integer expression that specified which index is accessed and the register which is accessed. Similar to the size expression of the register symbol, the expression is saved since it may not be evaluable when the symbol is created.

There are two symbol for classical data; these are the constant symbol and the loop iterator. The constant symbol represents a constant variable of differing types. To allow for different variable types, the symbol has a generic parameter \texttt{T}. Additionally, the generic parameter is restricted to implementing the number interface, indicating that it is a numeric type. Furthermore, as with the other symbols where a property may depend on a value that is not know at the time of creation, the constant symbol value is given by an expression. This expression is of the type \texttt{T}.

Secondly, the loop iterator symbol is the other symbol used to represent classical data; however, it is specifically designed for the loop statement of our language and its special properties. It is used to unroll the loop body and propagate the value of the current iteration of the loop. To achieve this, the symbol contains the start and end indices as integer expression; they can be evaluated when the code is being generated. Furthermore, the symbol contains a current value property which contains the value of the current iteration. When the code for the loop body is unrolled by being iterated, any reference to the iterator symbol will evaluate to the current value.  

The last three symbol are all related to the composite gates. Firstly, there is the composite gate symbol itself. It is created when a composite gate is declared and, later on, is used whenever it is referenced in a gate application statement. To allow for predefined gate, an interface is declared that represent the important attributes of a gate; these are the number of arguments to the gate and the gate type. The gate type differentiates between the different predefined gate such as the Hadamard or $X$ gate and the composite gates. This gate interface is implemented by the composite gate. Besides the properties required by the gate interface, the composite gate symbol consists of a block property and parameter property. The block property contains the code block that is the body of the composite gate; it is used to inline to statements of the gate whenever it is applied. Secondly, the parameters are a list of parameter symbols that represent the arguments that can be passed to the composite gate.   

The second kind of composite gate related symbols are parameter and parameter access symbols. Both represent an argument to a composite gate and serve as a placeholder for the symbol of the argument that if passed when the gate is applied. When inlining, the placeholder, \ie the parameter symbol, is mapped to the given argument. Furthermore, while the composite gates themselves can only operate on the previously discuss quantum data type symbols, the programmer does not specify the type of the argument, which can be both a qubit or quantum register, when declaring the composite gate. Therefore, we introduce a symbol which will ignore type checking until the composite gate is called and the arguments are specified. Then, if an argument is of an invalid type for a specific use, a type error is thrown. Similar to the register access, an additional parameter access symbol is required because an access cannot be represented as an expression; it inherits from the parameter symbol, has a reference to the parameter that is access and an integer expression that evaluates to the access index at generation time.

\subsection{Symbol Table}
The symbol table is a data structure that saves all symbol information and offers function for adding new symbols and retrieving symbol information. For example, a new symbol can be added with the \texttt{AddSymbol} function and symbol information can be obtained based on the identifier with with \texttt{GetSymbolInfo} function.

To allow for different symbol contexts, the scope data structure is used. Scopes are used enable the declaration of different variables with the same identifier in independent scopes, \ie two scope where neither is the others ancestor nor descendent. The scope class contains an identifier dictionary that maps a string, in this case representing the identifier, to the corresponding symbol. Because of the quantum if statement, a scope can also be guarded by a qubit. Therefore, a scope has an optional guard symbol that either references the symbol that guards the scope, and all descendants, or is null. Lastly, the scope contains a reference to the code block it belongs to. While the parse tree is traversed, each statement is added to the code block of the current scope. Later, the code block can be passed along in the generation to, \eg, create the loop statement belonging to the scope. 

The scopes are saved in the symbol on a stack. Each time a new code block is entered when traversing the parse tree, a new scope if pushed onto the scope stack. Similarly, each time a block is exited, the scope stack is popped to remove the latest scope from the data structure. To simplify the interactions with the scope stack, the symbol table contains both a current scope and current identifier map property; both reference the top-most scope on the stack and the identifier map of the current scope respectively.

While the scope data structure holds a reference to a reference to the guard symbol, the symbol is know before the creation of the current scope because first the if statement is traversed then the code block. Therefore, the class interacting with the symbol table would need to save the current identifier and pass it to the push scope function. To avoid this additional complexity, the symbol table hold a guard stack that can be interacted with by using the additional \texttt{PushGuard} and \texttt{PopGuard} functions. In turn, the symbol table can use the scope stack to pass the current guard to an newly created scope. Additionally, guards and scopes abstracted when using the symbol table such that the class traversing the parse tree only needs to push and pop the correct information and is not required to save the current guard information. 

Lastly, the symbol table contains a property that generate a unique identifier. To achieve this, it contains a private integer field \texttt{\_uniqueId} that is initialized with a value of zero. Each time the unique identifier property is retrieved, the id is incremented. The identifier is just the id with a ``id\_'' prefix. The property is used when generating the OpenQASM code as it does not allow for different variables with the same identifier. While this is a very simplistic approach, this resulting identifiers are always unique, as long as the same symbol table is used, and the resulting identifiers are predictable. This predictability is especially helpful when creating test cases for the translation of source code as we can simply give the expected target code. 