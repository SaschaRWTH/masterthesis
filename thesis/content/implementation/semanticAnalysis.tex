\section{Semantic Analysis}
\label{sec:implementation_semenaticAnalayis}
The second step in our compilation process is the semantic analysis of the input program. The analysis checks for any semantic errors in the code that can be detected before the next compilation step, the code generation. Our implementation of the semantic analysis differentiates between a declaration analysis and type checking. The declaration analysis is concerned with checking for errors related to the declaration of variables. For example, when a variable is used, it checks whether it was declared previously, or when a variable is declared, the analysis ensures that the identifier is not in use in the current scope. In contrast, the type checking ensures that the type of a variable is consistent with the use of the variable.

Both analyses are implemented as separate \texttt{Listeners}, as described in Sec.~\ref{sec:implementation_syntax_dataStructuresClasses}.
This is done to separate both classes and give them concrete purposes while making the overall structure of the compiler more modular. In turn, since both analyses are implemented separately, they currently each require a traversal of the parse tree, making the semantic analysis more inefficient. However, this can easily be addressed by writing a \texttt{Listener} that wraps both analyses, traverses the parse tree only once, and calls the corresponding function for each wrapped analysis.

\subsection{Declaration Analysis}
\label{sec:implementation_declarationAnalayis}
The declaration analysis reports any errors that are caused by the use of identifiers in invalid contexts; these are the use of an undeclared variable, the declaration of a variable in a context where it is already defined, and the use of a qubit in a code block that is guarded by the same qubit. A code block is guarded by a qubit if it is contained, directly or indirectly, in an if- or else-statement with the qubit as the control, \ie, either the code block or an ancestor code block is the block of the statement.
Additionally, it also reports a warning when a variable is declared but never used.

For its analysis, the class creates a symbol table and adds any symbol that is declared. Further, it executes all other functions required for a valid analysis with the symbol table, like pushing scopes onto and popping them from the stack when required in the parse tree traversal. Before adding a symbol to the table, \ie, every time the parse tree traversal exits a declaration, the \texttt{Listener} checks whether the identifier is already declared in the current context; if this is the case, the corresponding error is reported. Similarly, each time an identifier is referenced outside of a declaration, the analysis ensures that the variable is defined; otherwise, it reports the corresponding error as well. Lastly, whenever a register rule is encountered in the traversal, the analysis not only checks that the variable is declared but also whether the current code block is guarded by the referenced register. If this is the case, the analysis reports an error. While the register parsing rule is only used for gate applications and if-statements and not for function calls such as \texttt{sizeof}, only performing the check for the register rule cannot result in an invalid use of an identifier. This is the case because all function calls result in constant values and only refer to properties of a register, not the register itself; therefore, the compiled program will not have a reference to the register in the controlled context.

While the symbol table suffices for reporting the previous errors, it does not track the usage of symbols. Therefore, it cannot be used for the unused symbol warning. For this analysis, the class contains a dictionary that maps a symbol to the number of references. Each time a symbol is added to the symbol table, the corresponding entry in the dictionary is initialized to zero. Then, for every reference to the symbol, its usage counter is incremented. At the end of the tree traversal, specifically when exiting the main code block, the analysis iterates over all entries in the dictionary and reports a warning whenever the usage counter is still zero. However, the identifier consisting of only the underscore character ``\_'' is exempt so that it can be used as a throwaway variable, similar to its behavior in other programming languages.

\subsection{Type Checking}
\label{sec:implementation_typeCheckingAnalayis}
Type checking is used to ensure that any use of a symbol occurs in a valid context for this symbol. For example, while a qubit symbol can be used as the argument for a gate application, it does not represent a classical numerical value and, therefore, cannot be used in the context of a factor. Similar to the declaration analysis, a symbol table is used, and all symbols that are declared while traversing the tree are added to it. Additionally, the scopes are also pushed and popped according to the traversal to allow differently typed variables in independent scopes.

To check the use of a symbol, each grammar rule where an identifier can be used checks its type. For this, each function gets the identifier string and retrieves the corresponding symbol information from the symbol table. In the case of the register rule, only register symbols are allowed. However, if an index is given, \ie, a register is accessed, the given register symbol cannot be a qubit.

Next, identifiers in the factor rule can only be either a loop iterator or a constant symbol because a classical numeric value is required in expressions. In turn, register symbols, \eg, are not valid. In contrast, the \texttt{sizeof} function does only allow for register symbols. Since the \texttt{sizeof} function is the only one that takes identifiers as arguments and not expressions, it is the only one that requires type checking.

While identifiers in expressions can only reference classical data, gate applications require quantum data types as arguments. In this case, all symbols given as arguments are checked. If they are not a register, a type error is reported. Furthermore, while composite gate allow register are arguments, this is not the case for the predefined gate. Therefore, for predefined gates, all symbols that are not qubit are reported. Additionally, after the arguments were checked, it is ensured that the number of given arguments is equal to the number of required arguments. Besides the predefined gate, a composite gate can also be applied. In turn, they are referenced with their identifier. Therefore, in the gate grammar rule, only composite gate symbols are valid.

Similar to the application of predefined gates, the if-statement requires either a qubit or register access symbol. If they are not given, again, a type error is reported. In contrast, the range rule is not checked for type error but for an invalid range; this error is reported if the start index is greater than or equal to the end index, \ie, the size of the range would either be zero or negative.

Lastly, in all cases where a quantum data type is required, if the given symbol is a gate argument, the type checking is skipped and any issues are reported when the code is generated. This is done because composite gates do not require the type of an argument. Therefore, when traversing a composite gate code block, the compiler cannot know whether the argument is a register, qubit, or register access; the type checking is postponed to the code generation, when the types of the arguments are known.