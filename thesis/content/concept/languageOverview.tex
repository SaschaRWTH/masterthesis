\section{Language Overview}
\begin{itemize}
    \item Given an overview of the different feature of the language
    \item How do they work and what is the reason for implementing them
    \item Why are some feature (\eg implicit iteration) \emph{not} implemented
\end{itemize}

\subsection{Blocks and Scopes}
\label{sec:concept_blocksAndScope}
Similar to many other languages, Luie uses code blocks and corresponding scopes. Both the code blocks and scopes are used to structure the code and enable the reuse of identifiers in different contexts. Each Luie program is contained in the main code block. This main code block can contain arbitrarily many other code blocks. In turn, these code blocks can also contain any number of nested blocks. However, the main code block can only exist once and is the parent block of all others. Therefore, it also cannot depend on any other block. The main block not only differs from the others in terms of hierarchy but it is also the only block that can contain composite gate definitions. The composite gates are defined at the top of the main code block and are followed by other declarations or statements. 

Similar to the main code block, all other code blocks also consist of declarations and statements. A new code block is defined either in the definition of a composite gate or in the body of a control flow primitive; this includes the if-statement, else-statement, and for-loop. Each code block has a unique scope.

Scopes represent the variable context of a code block. Since each scope corresponds to one code block, they are also hierarchically structured. In turn, the parent of a scope is the scope that directly contains this scope, while ancestors are all scopes that also indirectly contain the scope.\improvement{bad formulation}
In contrast, the descendant of a scope are all scopes that are directly and indirectly contained in the scope. Furthermore two scopes are independent if one is neither an ancestor or descendant of the other. \info{same language can be applied to code blocks} 
In a given scope, the program can access all variables previously defined in this scope and all its ancestors, however not the variables of any descendants.  
In contrast, two independent scope do not have access to the variables defined in the other scope. Therefore, two independent if-statements can define a variable with the same name in their scope. Additionally, a scope can also overwrite the definition of a variable of an ancestor with its own definition while the ancestor's definition is not affected.

\subsection{Data Types}
\label{sec:concept_dataTypes}
Luie is mainly focused on being a quantum language with quantum control flow; this is also reflected in its data types. The language operates mostly on two types of quantum data, registers and qubits. Both behave as described in Sec.~\ref{sec:background_quantumComputing} where a register represents an array of qubits with a fixed length.
\unsure{Here or in implementation: while to the outsite register array of qubits, internally qubit special case of register (with length 1).}
Both registers and qubits are declared similarly. First, the \texttt{qubit} keyword is used to indicate the declaration. In the case of a register, the size of the register is given in brackets. Lastly, the identifier for the register or qubit is specified. For classical data types in most language, the variables need to be explicitly initialized. In quantum computers, however, qubits can only be initialized to $\ket{0}$. Therefore, Luie does not require or allow for an initialization value for qubits and registers but always defaults to $\ket{0}$ for all qubits and register entries.

The second class of data types in Luie are classical data types. They can be divided into constant values, constant variables, and loop iterators. In contrast to most classical language with similar data type, they are not referenced in the compiled program; they are only used at compile time and, therefore, must all have a constant value of known behavior. 
\todo{expand on this idea}
Constant values are the most simple data types and represent any value given directly in the program code. Currently, they can only be integers. 

Similar to constant values, constant variables, often just called constants, also have a constant values that is calculated when they are declared. However, they can not only be an integer but also unsigned integers and floating point values. Furthermore, they can be given by an expression when declared and reused as often as needed in the context they were declared in. Constants are declared with the \texttt{const} keyword and need to be given an identifier as well as th type of the constant. The type is either the \texttt{int}, \texttt{uint}, or \texttt{double} keyword. Lastly, an expression for the value of the constant is given.  

The loop iterator data type is declared when creating a loop and is also only accessible in the loop body. Its values corresponds to the current loop iteration, \eg for the first iteration $0$ and the last one $n - 1$ where $n$ is the number of iterations. Loop iterators are usually not implement as a special data type but by iterating, \eg, an integer; however, Luie does not allow of mutable, classical data type and, therefore, cannot increment an integer to iterate over a loop. In turn, it requires a special data type which value is constant for each iteration. 
\begin{itemize}
    \item Different data types
    \begin{itemize}
        \item Register
        \item Qubits (Registers with size 1)
        \item Iterators, in more detail in Sec.~\ref{sec:concept_controlFlow}
        \item constants (classical values)
        \item All classical data type are compile-time only
    \end{itemize}
\end{itemize}


\subsection{Basic Operations}
\label{sec:concept_basicOperations}
Any language needs some basic operations to manipulate its data type. While these operations may be addition, multiplication, and similar ones, quantum computers\unsure{gate-based quantum computer, not generally} manipulate their data with gates. Luie provides multiple predefined gates with which the qubits and registers can be manipulated. The syntax for applying gates to qubits is similar to other quantum language; the name of the gate is given and all parameters are listed next, separated with commas. 

The first kind of gate set natively available are the basic single qubit gates; these include the $X$, $Y$, and $Z$ gates as well as the Hadamard gate $H$. The logical extension of single qubit gates is the second gate set, the multi-qubit gates; they include the controlled-not gate $CX$ and the Toffoli gate $CCX$. These gates are not required for the overall gate set to be universal because they can easily be simulated with the control flow abilities provided by Luie. However, they are included because most programmers are used to them.
\unsure{bad reason, write better one!}
Finally, the parameterized gates are the last gate set. In contrast to the basic single and multi-qubit gates, they are not constant in their behavior but depend on a parameter. This parameter is given as an expression and is evaluated at compile time; it is given in parenthesis after the gate itself. Currently, the only parameterized gate available is the phase gate $p(\lambda)$.
The respective behavior and mathematical definition of all predefined gates in Luie is discussed in Sec.~\ref{sec:background_quantumGates}. Since the language provides both the Toffoli and Hadamard gates, the overall gate set is universal. Furthermore, any gates that are not predefined, can easily be implemented as composite gate; they are described in Sec.~\ref{sec:concept_compositeGates}.

However, one feature not provided for gate applications is implicit iteration. Implicit iteration allows gates that operate on a single qubit to be applied to an entire register instead by giving the register as a parameter. Since Luie provides an loop statements with which a gate can explicitly be applied to entire register with additional control over the application, implicit iteration is not implemented in the language.  

\subsection{Control Flow}
\label{sec:concept_controlFlow}
\begin{itemize}
    \item qif-/else-statements
    \begin{itemize}
        \item if statement in super position
        \item optional else statement
        \item does not allow for boolean expressions, only single qubit parameter
        \item guards codeblock
        \item can include statements, declarations
        \item declarations however always performed, not depending on value of guard
        \item can similarly to for loops increase number of qubits, however not as bad, because only one declaration instead of a declaration for each iteration 
    \end{itemize}
\end{itemize}
The main focus of the proposed language is quantum control flow. Therefore, Luie provides two different control flow statements, a loop statement with a fixed number of iterations and an if statement operating of data in superposition. 

The loop statement can be used to iterate over a code block a fixed number of times. While the number of iterations needs to be known at compile time, it can depend on constants know at compile time such as the size of a register. However, it can, \eg, not depend on the measurement of a qubit or even the value of a qubit in superposition. This relates back to the principle of synchronization, as described in Sec.~\ref{sec:background_controlflow_synchronization}. Additionally, the body of the loop can depend on iteration index, \ie the current value of the iterator. Therefore, the loop statement can, \eg, iterate over a register or part of it and apply a series of gates to each qubit. Furthermore, the loop body can also include all statements can declarations available for each code bock. In turn, the loop statement can contain nested loops or parts of its body can be guarded by an if statement. However, the target language of the compiler and quantum computers in general do not have a concept of local variable. Therefore, while declarations can be performed, a declaration in a loop body is translated to a ``global'' declaration of a qubit for each iteration. This can significantly increase the qubit count of the program. To optimize the current implementation, a single qubit could be declared that is reset or measured at the end of each iteration and, thereby, reducing the required number of qubits.

If statements

\subsection{Expressions}
\label{sec:concept_expressions}
The language allows for complex expression that are evaluated at compile time. These expression can be used to access specific indices of a register or define the range of a for loop. Besides the typical operations like addition and multiplication, the language also implements different functions. In the following, we want to present the operations and different functions that expressions can use, what data types they operate on, and how they behave. 

\dots
\begin{itemize}
    \item Consists of expressions, terms and factors
    \begin{itemize}
        \item Expressions consist of expression, operator, and term or just a term
        \item Term consists of term, operator, and factor or just a factor
        \item Factor consists of expression in parentheses, a negated factor, number, identifier or function call
        \item Different functions
    \end{itemize}
\end{itemize}

\subsection{Composite Gates}
\label{sec:concept_compositeGates}
Similar to OpenQASM, Luie also allows for the declaration of composite gates. They can be used to declare a custom gate that applies the gate combination specified in the gate body. This can be particularly useful for gate combinations often used in the code to reduce redundancy and, further, improve the readability of the code. For example, the swap gate can be defined on two qubits where three controlled-not gates are applied such that the values of both qubits are swapped. In this case, not only are three gates reduced to only one but the code clearly indicated that the values are swapped without prior knowledge on the effect of the controlled-not gates.

While the concept of a composite gate is also available in OpenQASM, Luie expands on the possibilities provided by OpenQASM's implementation. Firstly, the gate does not only allow for simple gate application statements but also for the control flow statements provided by Luie; this includes the loop statements and if statements in superposition, only qubit and register declarations are prohibited in the body of gate declarations. In contrast to composite gates in OpenQasm, not only qubits are allowed as parameter but also registers. Therefore, registers can be given as parameters and the loop statement can iterate over them resulting in gates that can depend on the length of a register and do not need to be reimplemented for each different size. However, in contrast to OpenQASM, the language currently does not allow of parameterized composite gates.   

\begin{figure}[htp]
    \centering     
    \lstinputlisting[style=Luie]{../figures/code/qft.luie}
    \caption{Luie gate definition for the Quantum Fourier Transform.}
    \label{fig:qft_example}
\end{figure}

Two examples for composite gates are depicted in Fig.~\ref{fig:qft_example}. The first gate is a simple definition for the commonly used, and often predefined, \texttt{swap} gate. Below, a gate definition for the quantum Fourier transform is given. It not only references the previous swap gate, but also uses both loop and if statements. Firstly, the gate iterates over all qubits in the given register $reg$ with size $n$. In each iteration, the gate first applies the Hadamard gate to the qubits and, again, iterates over all remaining qubits in the register and applies the phase gate depending on the value of the qubit in superposition. Additionally, the parameter for the phase gate is calculated based on the offset of both indices. After iterating through the entire register and applying the corresponding gate, the gate swaps each qubit at index $i$ with the qubit at index $n - i$ for $0 \geq i \geq \floor*{\frac{n}{2}}$. 