\section{Language Overview}
\begin{itemize}
    \item Given an overview of the different feature of the language
    \item How do they work and what is the reason for implementing them
    \item Why are some feature (\eg implicit iteration) \emph{not} implemented
\end{itemize}

\subsection{Blocks and Scopes}
\label{sec:concept_blocksAndScope}
Similar to many other languages, Luie uses code blocks and corresponding scopes. Both the code blocks and scopes are used to structure the code and enable the reuse of identifiers in different contexts. Each Luie program is contained in the main code block. This main code block can contain arbitrarily many other code blocks. In turn, these code blocks can also contain any number of nested blocks. However, the main code block can only exist once and is the parent block of all others. Therefore, it also cannot depend on any other block. The main block not only differs from the others in terms of hierarchy but it is also the only block that can contain composite gate definitions. The composite gates are defined at the top of the main code block and are followed by other declarations or statements. 

Similar to the main code block, all other code blocks also consist of declarations and statements. A new code block is defined either in the definition of a composite gate or in the body of a control flow primitive; this includes the if-statement, else-statement, and for-loop. Each code block has a unique scope.

Scopes represent the variable context of a code block. Since each scope corresponds to one code block, they are also hierarchically structured. In turn, the parent of a scope is the scope that directly contains this scope, while ancestors are all scopes that also indirectly contain the scope.\improvement{bad formulation}
In contrast, the descendant of a scope are all scopes that are directly and indirectly contained in the scope. Furthermore two scopes are independent if one is neither an ancestor or descendant of the other. \info{same language can be applied to code blocks} 
In a given scope, the program can access all variables previously defined in this scope and all its ancestors, however not the variables of any descendants.  
In contrast, two independent scope do not have access to the variables defined in the other scope. Therefore, two independent if-statements can define a variable with the same name in their scope. Additionally, a scope can also overwrite the definition of a variable of an ancestor with its own definition while the ancestor's definition is not affected.

\subsection{Data Types}
\label{sec:concept_dataTypes}
Luie is mainly focused on being a quantum language with quantum control flow; this is also reflected in its data types. The language operates mostly on two types of quantum data, registers and qubits. Both behave as described in Sec.~\ref{sec:background_quantumComputing} where a register represents an array of qubits with a fixed length.
\unsure{Here or in implementation: while to the outsite register array of qubits, internally qubit special case of register (with length 1).}
\dots
\begin{itemize}
    \item Different data types
    \begin{itemize}
        \item Register
        \item Qubits (Registers with size 1)
        \item Iterators, in more detail in Sec.~\ref{sec:concept_controlFlow}
    \end{itemize}
    \item How are qubits and register declared?
\end{itemize}


\subsection{Basic Operations}
\label{sec:concept_basicOperations}
\begin{itemize}
    \item Parameterized gates: p
    \item Overall universal gate set, any gate can be defined with composite gates for later use
\end{itemize}
Any language needs some basic operations to manipulate its data type. While these operations may be addition, multiplication, and similar ones, quantum computers\unsure{gate-based quantum computer, not generally} manipulate their data with gates. Luie provides multiple predefined gates with which the qubits and registers can be manipulated. The syntax for applying gates to qubits is similar to other quantum language; the name of the gate is given and all parameters are listed next, separated with commas. 

The first kind of gate set natively available are the basic single qubit gates; these include the $X$, $Y$, and $Z$ gates as well as the Hadamard gate $H$. The logical extension of single qubit gates is the second gate set, the multi-qubit gates; they include the controlled-not gate $CX$ and the Toffoli gate $CCX$. These gates are not required for the overall gate set to be universal because they can easily be simulated with the control flow abilities provided by Luie. However, they are included because most programmers are used to them.
\unsure{bad reason, write better one!}
Finally, the parameterized gates are the last gate set. In contrast to the basic single and multi-qubit gates, they are not constant in their behavior but depend on a parameter. This parameter is given as an expression and is evaluated at compile time; it is given in parenthesis after the gate itself. Currently, the only parameterized gate available is the phase gate $p(\lambda)$.
The respective behavior and mathematical definition of all predefined gates in Luie is discussed in Sec.~\ref{sec:background_quantumGates}. Since the language provides both the Toffoli and Hadamard gates, the overall gate set is universal. Furthermore, any gates that are not predefined, can easily be implemented as composite gate; they are described in Sec.\ref{ce} 

\subsection{Control Flow}
\label{sec:concept_controlFlow}
\begin{itemize}
    \item different kinds of control flow primitives
    \item qif-/else-statements
    \begin{itemize}
        \item describe
    \end{itemize}
    \item for-loops
    \begin{itemize}
        \item describe
    \end{itemize}
\end{itemize}

\subsection{Expressions}
\label{sec:concept_expressions}
The language allows for complex expression that are evaluated at compile time. These expression can be used to access specific indices of a register or define the range of a for loop. Besides the typical operations like addition and multiplication, the language also implements different functions. In the following, we want to present the operations and different functions that expressions can use, what data types they operate on, and how they behave. 

\dots
\begin{itemize}
    \item Consists of expressions, terms and factors
    \begin{itemize}
        \item Expressions consist of expression, operator, and term or just a term
        \item Term consists of term, operator, and factor or just a factor
        \item Factor consists of expression in parentheses, a negated factor, number, identifier or function call
        \item Different functions
    \end{itemize}
\end{itemize}

\subsection{Composite Gates}
\label{sec:concept_compositeGates}
\begin{itemize}
    \item Similar to composite gates in language OpenQASM
    \item Useful for gate combinations commonly used,
    \item Can also make code more readable (indirect code comments)
    \item Some significant changes
    \item Can input registers (not implicit iteration)
    \item Access to control flow statements provided by luie
    \item Example of composite gate, quantum Fourier transform depicted in Fig.~\ref{fig:qft_example}
\end{itemize}

\begin{figure}[htp]
    \centering     
    \lstinputlisting[style=Luie]{../figures/code/qft.luie}
    \caption{Luie gate definition for the Quantum Fourier Transform.}
    \label{fig:qft_example}
\end{figure}