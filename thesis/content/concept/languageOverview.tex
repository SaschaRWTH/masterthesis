\section{Language Overview}
In the following section, we discuss the different concepts that the proposed language provides for writing quantum programs. Furthermore, we discuss their behavior and some use cases for them. Additionally, we explain why some features of other languages were not incorporated and the reasons for some special behaviors. 

The idea for our proposed language is to provide a high-level language with the capabilities of the Quantum Control Machine (QCM). For this, we want to remove low-level concepts, such as jump instructions, and add high-level ones, such as code blocks with variable contexts and additional data types. Additionally, since jump instructions in superposition are removed, we need to add other control flow statements so that the language is as expressive as the QCM. For this, we introduce two basic control flow statements: the loop statement, which is unrolled at compile time, and the quantum if- and else-statements. Based on these ideas, we propose the loop unrolled, if-else, programming language ``Luie''.

Firstly, we discuss code blocks and their corresponding variable contexts, or scopes. Then, we introduce the data types that are available in the language. Next, the basic operations as well as the more complex control flow statements are listed and explained. This is followed by an overview of the possible expressions and the available operations and built-in functions. Lastly, we discuss the composite gates of the language. 

%The following description is a high level overview of the concepts and functionalities of the language. While we discuss a high-level overview in the following, the concrete syntax and implementation of these features is discussed in Ch.~\ref{ch:implementation}.

\subsection{Blocks and Scopes}
\label{sec:concept_blocksAndScope}
Similar to many other languages, Luie uses code blocks and corresponding scopes. Both the code blocks and scopes are used to structure the code and enable the reuse of identifiers in different contexts. Code blocks and scopes are hierarchically structured; the parent of a code block is the block that directly contains this scope, while ancestor blocks are all blocks that contain the block.
In contrast, the descendants of a block are all blocks that are directly and indirectly contained in the block. Furthermore, two blocks are independent if one is neither an ancestor nor a descendant of the other. Since each scope corresponds to a code block, the same terms can be used for them.

Each Luie program is contained in the main code block. This main code block can contain arbitrarily many other code blocks. In turn, these code blocks can also contain any number of nested blocks. However, the main code block can only exist once and is the ancestor of all others. Therefore, it also cannot depend on any other block. The main block not only differs from the others in terms of hierarchy, but it is also the only block that can contain composite gate declarations. The composite gates are declared at the top of the main code block and are followed by other declarations or statements. 

Similar to the main code block, all other code blocks also consist of declarations and statements. A new code block is defined either in the declaration of a composite gate or in the body of a control flow primitive; this includes the if-statement, else-statement, and loop statement. Additionally, each code block has a unique scope.

Scopes represent the variable context of a code block. In a given scope, the program can access all variables previously defined in this scope and all its ancestors; however, it cannot access the variables of any descendants.
In contrast, two independent scopes do not have access to the variables defined in the other scope. Therefore, two independent if-statements can define a variable with the same name in their scope. 
% Additionally, a scope can also overwrite the definition of a variable of an ancestor with its own definition while the ancestor's definition is not affected.

\subsection{Data Types}
\label{sec:concept_dataTypes}
Luie is mainly focused on being a quantum language with quantum control flow; this is also reflected in its data types. The language operates mostly on two types of quantum data, registers and qubits. Both behave as described in Sec.~\ref{sec:background_quantumComputing}, where a register represents an array of qubits with a fixed length.
Both registers and qubits are declared similarly. First, the \texttt{qubit} keyword is used to indicate the declaration. In the case of a register, the size of the register is given in brackets. Lastly, the identifier for the register or qubit is specified. For data types in most classical languages, the variables need to be explicitly initialized. In quantum computers, however, qubits can only be initialized to $\ket{0}$. Therefore, Luie does not require or allow for an initialization value for qubits and registers but always defaults to $\ket{0}$ for all qubits and register entries.

The second class of data types in Luie are classical data types. They can be divided into constant values, named constants, and loop iterators. In contrast to most classical languages with similar data types, they are not referenced in the compiled program; they are only used at compile time and, therefore, must all have a constant value or a known behavior. For example, while the value of an integer constant is constant, the value of a loop iterator changes with each iteration but is constant in each.
Constant values are the most simple data types and represent any value given directly in the program code. 

Similar to constant values, named constants, often just called constants, also have a constant value that is saved as an expression when they are declared and evaluated when the code is generated. However, they can not only be integers but also unsigned integers and floating point values. Furthermore, they can be given by an expression when declared and referenced as often as needed in the context they were declared in. Constants are declared with the \texttt{const} keyword and need to be given an identifier as well as the type of the constant. The type is either the \texttt{int}, \texttt{uint}, or \texttt{double} keyword. Lastly, an expression for the value of the constant is given.

The loop iterator data type is declared when creating a loop and is also only accessible in the loop body. Its value corresponds to the current loop iteration, \eg for the first iteration zero and the last one $n - 1$, where $n$ is the number of iterations. Loop iterators are usually not implemented as a special data type but by incrementing, \eg, an integer; however, Luie does not allow mutable, classical data type and, therefore, cannot increment an integer to iterate over a loop. In turn, it requires a special data type whose value is constant for each iteration.

\subsection{Basic Operations}
\label{sec:concept_basicOperations}
Any language needs some basic operations to manipulate its data types. While these operations may be addition or multiplication on classical computers, quantum computers manipulate their data with gates. Luie provides multiple predefined gates with which the qubits and registers can be manipulated. The syntax for applying gates to qubits is similar to other quantum languages; the name of the gate is given, and all parameters are listed next, separated with commas.

The first kind of gate set natively available consists of basic single-qubit gates; these include the $X$, $Y$, and $Z$ gates as well as the Hadamard gate $H$. The logical extension of single-qubit gates is the second gate set, the multi-qubit gates; they include the controlled-not gate $CX$ and the Toffoli gate $CCX$. These gates are not required for the overall gate set to be universal because they can easily be simulated with the control flow statements available in the language. However, they are included because most programmers are used to them; internally, they are translated to controlled $X$ gates.
Finally, the parameterized gates are the last gate set. In contrast to the basic single- and multi-qubit gates, they are not constant in their behavior but depend on one or multiple parameters. These parameters are given as expressions and are evaluated at compile time; they are given in parentheses after the gate and separated by commas. Currently, the only parameterized gate available is the phase gate $P(\lambda)$.
The respective behavior and mathematical definition of all predefined gates in Luie are discussed in Sec.~\ref{sec:background_quantumGates}. Since the language provides both the Toffoli and Hadamard gates, the overall gate set is universal. Furthermore, any gates that are not predefined can easily be implemented as composite gates; they are described in Sec.~\ref{sec:concept_compositeGates}.

However, one feature not provided for gate applications is implicit iteration. Implicit iteration allows gates that operate on a single qubit to be applied to an entire register instead by giving the register as an argument. Since Luie provides loop statements with which a gate can explicitly be applied to an entire register with additional control over the application, implicit iteration is not implemented in the language.

\subsection{Measurements}
\label{sec:concept_measurement}
For a quantum circuit to be of any use, measurements are required. However, there are many options for implementing measurements. Our language only implements implicit measurements and does not allow the explicit measurement of a qubit at an arbitrary point in the circuit. While explicit measurement may allow for more flexibility and manual optimization of qubit usage, both approaches can implement the same set of algorithms. Furthermore, our language focuses mainly on control flow statements, so we decided on a simple approach for the measurement of qubits. Additionally, explicit measurement statements in the language would require further classical data types to store the result of the measurement; this would increase the overall complexity of the language and require the user to add additional declarations for each explicit measurement.

In our language, the measurements are implicitly added at the end of each qubit wire. Thus, the compiler declares both a bit for each qubit and a classical register for each quantum register. Next, each qubit and quantum register is measured, and the result of the measurement is saved to the corresponding bit or classical register.

\subsection{Control Flow}
\label{sec:concept_controlFlow}
The main focus of the proposed language is quantum control flow. Therefore, Luie provides two different control flow statements: a loop statement with a fixed number of iterations and an if-statement operating on data in superposition. 

The loop statement can be used to iterate over a code block a fixed number of times. While the number of iterations needs to be known at compile time, it can depend on constants known at compile time, such as the size of a register. However, it can, \eg, not depend on the measurement of a qubit or the value of a qubit in superposition. This relates back to the principle of synchronization, as described in Sec.~\ref{sec:background_controlflow_synchronization}. Additionally, the body of the loop can depend on the iteration index, \ie the current value of the iterator. Therefore, the loop statement can, \eg, iterate over a register or part of it and apply a series of gates to each qubit. Furthermore, the loop body can also include all statements and declarations available for each code block. In turn, the loop statement can contain nested loops, or parts of its body can be guarded by an if-statement. However, the target language of the compiler and quantum computers in general do not have a concept of local variables. Therefore, while declarations can be performed, a declaration in a loop body is translated to a ``global'' declaration of a qubit for each iteration. This can significantly increase the qubit count of the program. To optimize the current implementation, a single qubit could be declared that is reset or measured at the end of each iteration, thereby reducing the required number of qubits. However, this optimization is currently not implemented.

In contrast to loop statements, the if-statements do not depend on constant data known at compile time; their execution, however, depends on the value of a qubit in superposition. Further, the guard of the statement can only be a single qubit, not a register, and cannot include boolean expressions.
The body of the statement can contain any other statements, including further if- and loop statements, as well as declarations. When compiled, each gate application inside the body is guarded by the given qubit and translated to a controlled version of the gate where the guard is the control. However, the declaration is not dependent on the value of the guard. Therefore, similar to declarations inside loop statements, the declaration is always performed independent of the guard's value. In turn, the declaration of qubits or registers inside an if-statement can increase the qubit count. However, since it is only performed once and not for each iteration, the gate count is not affected to the same extent as the declaration in loop statements. Additionally, besides the main code block, the if-statement also offers an optional else case. In this case, the translated statements of the else-block are controlled by the negated guard. 

\subsection{Expressions}
\label{sec:concept_expressions}
The language allows for complex expressions that are evaluated at compile time. These expressions can be used to access specific indices of a register or define the range of an iterator used by a loop statement. Besides the typical operations like addition and multiplication, the language also implements different functions. However, the targeted quantum computers should not need to and, in some cases, cannot evaluate these expressions; their values need to be not only constant but also evaluated at compile time. Furthermore, they can neither depend on the measurement nor the value of a qubit.

The first kind of operations are the basic operations; they include addition and subtraction, multiplication and division, and the negation. The grammar of the language is designed such that the usual operator precedences are respected. Additionally, parentheses can be used to adjust this order. The operations operate either on an integer value or an identifier. If an integer value is given, it can easily be parsed to an integer and used with the operations. However, the identifier can either be a constant or an iterator. For either, the compiler looks up the current value in the symbol table and evaluates the remaining expression. 

Besides basic operations, the language provides more complex functions that can be used for specific calculations. Firstly, the \texttt{sizeof} function takes a register as an input and returns the size of the given register. This can be useful for creating a loop statement that iterates over the size of a register. Furthermore, it can be used to create a register based on the size of another. Next, the \texttt{power} function takes two expressions as arguments, evaluates them, and raises the first argument's value to the value of the second argument. Lastly, similar to the \texttt{power} function, the \texttt{min} and \texttt{max} functions both take two expressions as arguments and return the minimum and maximum value of the evaluated expressions, respectively.

Luie provides two different expressions for creating ranges. Since they create ranges, or more specifically loop iterators for a given range, and the other operations only operate on basic numeric types, \eg integers and floating point values, they are not grouped together with the others but implemented separately. The first way to define a range is to give the start and end values separated by two dots, \eg $1\texttt{..}9$ for iterating from one to nine. In this case, both the start and end values are included in the iteration. However, this expression can only take integers for the start and end values, not expressions; this limitation is imposed such that the expression remains readable. The other operation for creating ranges is the \texttt{range} keyword followed by the start and end values in parenthesis and separated by a comma, \eg $\texttt{range}(1, 9)$. For this expression, the parameters can also be given as expressions. Furthermore, the \texttt{range} expression also provides a shorthand, where only the length $len$ of the range is given. In this case, it will always start from zero and iterate to $len - 1$. This is most useful for creating ranges to iterate over registers. 

Lastly, in contrast to many other languages, the access of a register is not implemented as an expression. A register access, \ie a qubit, is not a classical data type and cannot be used in any context other than as a gate parameter or as an if-statement guard. Therefore, it is implemented as a separate grammar rule and not as an expression.

\subsection{Composite Gates}
\label{sec:concept_compositeGates}
Similar to OpenQASM, Luie also allows for the declaration of composite gates. They can be used to declare a custom gate that applies the gate combination specified in the gate body. This can be particularly useful for gate combinations often used in the code to reduce redundancy and, furthermore, improve the readability of the code. For example, the swap gate can be defined on two qubits where three controlled-not gates are applied such that the values of both qubits are swapped. In this case, not only are three gates reduced to only one, but the code clearly indicated that the values are swapped without prior knowledge of the effect of the controlled-not gates.

While the concept of a composite gate is also available in OpenQASM, Luie expands on the possibilities provided by OpenQASM's implementation. Firstly, the gate declaration does not only allow for simple gate application statements but also for the control flow statements provided by Luie. This includes the loop statements and if-statements in superposition; only qubit and register declarations are prohibited in the body of gate declarations. In contrast to composite gates in OpenQASM, not only qubits are allowed as arguments but also registers. Therefore, registers can be given as arguments, and the loop statement can iterate over them, resulting in gates that can depend on the length of a register and do not need to be reimplemented for each different size. However, in contrast to OpenQASM, the language currently does not allow for parameterized composite gates.

\begin{figure}[htp]
    \centering     
    \lstinputlisting[style=Luie]{../figures/code/concept/qft.luie}
    \caption{Luie gate definition for the Quantum Fourier Transform.}
    \label{fig:qft_example}
\end{figure}

Two examples of composite gates are depicted in Fig.~\ref{fig:qft_example}. The first gate is a simple definition for the commonly used, and often predefined, \texttt{swap} gate. Below, a gate definition for the quantum Fourier transform is given. It not only references the previous swap gate but also uses both if- and loop statements. Firstly, the gate iterates over all qubits in the given register $reg$ with size $n$. In each iteration, the gate first applies the Hadamard gate to the qubits and, again, iterates over all remaining qubits in the register and applies the phase gate depending on the value of the qubit in superposition. Additionally, the parameter for the phase gate is calculated based on the offset of both indices. After iterating through the entire register and applying the corresponding gate, the gate swaps each qubit at index $i$ with the qubit at index $n - i$ for $0 \leq i \leq \floor*{\frac{n}{2}}$.