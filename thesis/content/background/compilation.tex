\section{Compilation}
The execution on a computer is controlled by a program. This program is written in a specific language unique to the hardware of the computer, machine code. However, this language is often neither human readable nor suitable for writing complex systems. Therefore, most programs are written in a more accessible language. The program can then be translated to the machine code with a \emph{compiler}. 

A compiler translates a program written in a source language to a program in a target language. The compilation process can be divided into multiple steps. The first step ist the \emph{lexical analysis} of the source code. Next, the source codes syntactic structure is analyzed be the \emph{parser}. Then, the code is \emph{semantically analyzed} and the target code is generated in the \emph{code generation} step. Lastly, the compiler may \emph{optimize} the target code~\cite{Oliv07}. In the following, we be discuss the different steps of a compiler individually.

\subsection{Lexer (Lexical Analysis)}
The lexical analysis of the source program takes the character stream and groups together associated characters producing a sequence of tokens~\cite{Oliv07}. Therefore, the step is also referred to as \emph{tokenization}~\cite{Gref99}. The process can be divided into the \emph{scanning} and \emph{screening} of the character and token sequence~\cite{DeRe74}.

The scanning process groups together substrings into textual elements, or tokens. In contrast to the characters and substrings, these tokens have defined meanings and may have additional attributes. For example, they may include identifiers, operator, comments, and spaces. In the case of the identifier token, an additional attribute could be the string value of the identifier. They can be specified with the help of a regular grammar or regular expression~\cite{DeRe74,VSSD07}.\unsure{\cite{VSSD07} is extensive book, cite specific chapter somehow?}  

After being divided into a sequence of tokens, the screening step drops any characters or sequences of characters not relevant to the compilation from the program code. 
These may include characters such as spaces and tabs, or white space in general, and character sequences such as comments. 
Further, is may also recognize additional special symbols, such as keywords, and map them to a designated token. For example, a identifier with a value of ``while'' could be mapped to the corresponding token of the \texttt{while}-toke.\cite{DeRe74}.

Some example regular expressions for a lexical analysis are depicted in Fig.~\ref{fig:example_lexer}. The code depicts regular expressions for integers, identifiers, comments, and white space in ANTLR syntax.
\improvement{add reference to section discussing ANTLR}
The integer can either be an arbitrary sequence of characters between zero and nine without a leading zero or just zero with a length of at least one. Similarly, an identifier is a sequence of lower and upper case alphabetical characters, numbers, and underscores with a length of at least 1 and without a leading number. In contrast, a comment is any string starting with a double slash until the line break and white space is any white space characters. Additionally, the comment and white space also define a scanning step where both are discarded.

\begin{figure}[htp]
    \centering
    \lstinputlisting[style=ANTLR]{../figures/code/example_lexer.g4}
    \caption{An example of a regular grammar for the lexical analysis.}
    \label{fig:example_lexer}
\end{figure}

\subsection{Parser (Syntax Analysis)}
The lexical analysis of the compiler yields a sequence of token with a known meaning; the structure of the program, however, is not apparent in the token sequence. For example, an operator-token does not indicate what the operands are. To gain knowledge of the structure of the program, the parser step analyzes the syntactic structure of the source program and creates a parse tree from it. The compiler can then use the tree by, \eg, walking over it to generate the target code. This step should also detect and report any syntactical errors, like a missing closing parentheses~\cite{VSSD07}.

While the lexical analysis can be achieved with a regular expression, the syntactic structure of a program is represented by a context-free grammar. There exists two main kinds of parsing a grammar, either top-down or bottom-up.
Top-down parsing creates a parse tree based on an input sequence of tokens starting from the root and creating the nodes in a depth-first approach. In contrast, bottom-up parsing builds the parse tree from the leaves up to the root~\cite{VSSD07}.\improvement{Add short description of recursive descrent parsing -> lookahead and $LL(k)$ grammars \& LR grammar}

An example grammar for parsing simple integer expressions is depicted in Fig.~\ref{fig:example_parser}. Similar to the regular expressions in Fig.~\ref{fig:example_lexer}, the grammar is given in ANTLR syntax. An expression is either the sum of another expression and a term or just a term. In turn, a term is either the product of a term and a factor or just a factor. Lastly, a factor is either an expression in parenthesis or an integer. Here, the definition of an integer is omitted. However, it can be seen in the previous example. The grammar is defined such that a generated parse tree inherently adheres to the order of operations.

\begin{figure}[htp]
    \centering
    \lstinputlisting[style=ANTLR]{../figures/code/example_parser.g4}
    \caption{An example of a context-free grammar for parsing simple expressions.}
    \label{fig:example_parser}
\end{figure}


\subsection{Semantic Analysis}
While the syntactic analysis is accomplished by context-free grammars, an analysis of the program including context is practical to semantic errors, \eg the use of undefined variables. \dots

\subsection{Code Generation}

\subsection{Optimization}
\label{sec:background_compiler_codeOptimization}
\begin{itemize}
    \item Different optimization techniques
    \begin{itemize}
        \item Constant folding or constant propagation
        \item Peephole optimization
    \end{itemize}
\end{itemize}